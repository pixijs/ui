"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[8684],{"./node_modules/pixi.js/lib/app/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class ResizePlugin{static init(options){Object.defineProperty(this,"resizeTo",{set(dom){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=dom,dom&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;let width,height;if(this._cancelResize(),this._resizeTo===globalThis.window)width=globalThis.innerWidth,height=globalThis.innerHeight;else{const{clientWidth,clientHeight}=this._resizeTo;width=clientWidth,height=clientHeight}this.renderer.resize(width,height),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=options.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=Extensions.Ag.Application;var ticker_const=__webpack_require__("./node_modules/pixi.js/lib/ticker/const.mjs"),Ticker=__webpack_require__("./node_modules/pixi.js/lib/ticker/Ticker.mjs");class TickerPlugin{static init(options){options=Object.assign({autoStart:!0,sharedTicker:!1},options),Object.defineProperty(this,"ticker",{set(ticker){this._ticker&&this._ticker.remove(this.render,this),this._ticker=ticker,ticker&&ticker.add(this.render,this,ticker_const.d.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=options.sharedTicker?Ticker.R.shared:new Ticker.R,options.autoStart&&this.start()}static destroy(){if(this._ticker){const oldTicker=this._ticker;this.ticker=null,oldTicker.destroy()}}}TickerPlugin.extension=Extensions.Ag.Application,Extensions.XO.add(ResizePlugin),Extensions.XO.add(TickerPlugin)},"./node_modules/pixi.js/lib/filters/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class FilterPipe{constructor(renderer){this._renderer=renderer}push(filterEffect,container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container,filterEffect})}pop(_filterEffect,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(instruction){"pushFilter"===instruction.action?this._renderer.filter.push(instruction):"popFilter"===instruction.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"filter"};var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),Point=__webpack_require__("./node_modules/pixi.js/lib/maths/point/Point.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),Geometry=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),Bounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"),matrixAndBoundsPool=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");const tempMatrix=new Matrix.u;function getFastGlobalBounds(target,bounds){bounds.clear(),_getGlobalBoundsRecursive(target,bounds),bounds.isValid||bounds.set(0,0,0,0);const renderGroup=target.renderGroup||target.parentRenderGroup;return bounds.applyMatrix(renderGroup.worldTransform),bounds}function _getGlobalBoundsRecursive(target,bounds){if(7!==target.localDisplayStatus||!target.measurable)return;const manageEffects=!!target.effects.length;let localBounds=bounds;if((target.renderGroup||manageEffects)&&(localBounds=matrixAndBoundsPool.o.get().clear()),target.boundsArea)bounds.addRect(target.boundsArea,target.worldTransform);else{if(target.renderPipeId){const viewBounds=target.bounds;localBounds.addFrame(viewBounds.minX,viewBounds.minY,viewBounds.maxX,viewBounds.maxY,target.groupTransform)}const children=target.children;for(let i=0;i<children.length;i++)_getGlobalBoundsRecursive(children[i],localBounds)}if(manageEffects){let advanced=!1;for(let i=0;i<target.effects.length;i++)target.effects[i].addBounds&&(advanced||(advanced=!0,localBounds.applyMatrix(target.parentRenderGroup.worldTransform)),target.effects[i].addBounds(localBounds,!0));advanced&&(localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert()),bounds.addBounds(localBounds,target.relativeGroupTransform)),bounds.addBounds(localBounds),matrixAndBoundsPool.o.return(localBounds)}else target.renderGroup&&(bounds.addBounds(localBounds,target.relativeGroupTransform),matrixAndBoundsPool.o.return(localBounds))}var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");const quadGeometry=new Geometry.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(renderer){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup.T({}),this.renderer=renderer}get activeBackTexture(){return this._activeFilterData?.backTexture}push(instruction){const renderer=this.renderer,filters=instruction.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const filterData=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,0===filters.length)return void(filterData.skip=!0);const bounds=filterData.bounds;if(instruction.renderables?function getGlobalRenderableBounds(renderables,bounds){bounds.clear();const tempMatrix=bounds.matrix;for(let i=0;i<renderables.length;i++){const renderable=renderables[i];renderable.globalDisplayStatus<7||(bounds.matrix=renderable.worldTransform,bounds.addBounds(renderable.bounds))}return bounds.matrix=tempMatrix,bounds}(instruction.renderables,bounds):instruction.filterEffect.filterArea?(bounds.clear(),bounds.addRect(instruction.filterEffect.filterArea),bounds.applyMatrix(instruction.container.worldTransform)):getFastGlobalBounds(instruction.container,bounds),instruction.container){const filterFrameTransform=(instruction.container.renderGroup||instruction.container.parentRenderGroup).cacheToLocalTransform;filterFrameTransform&&bounds.applyMatrix(filterFrameTransform)}const colorTextureSource=renderer.renderTarget.renderTarget.colorTexture.source;let resolution=1/0,padding=0,antialias=!0,blendRequired=!1,enabled=!1,clipToViewport=!0;for(let i=0;i<filters.length;i++){const filter=filters[i];resolution=Math.min(resolution,"inherit"===filter.resolution?colorTextureSource._resolution:filter.resolution),padding+=filter.padding,"off"===filter.antialias?antialias=!1:"inherit"===filter.antialias&&antialias&&(antialias=colorTextureSource.antialias),filter.clipToViewport||(clipToViewport=!1);if(!!!(filter.compatibleRenderers&renderer.type)){enabled=!1;break}if(filter.blendRequired&&!(renderer.backBuffer?.useBackBuffer??1)){(0,warn.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),enabled=!1;break}enabled=filter.enabled||enabled,blendRequired||(blendRequired=filter.blendRequired)}if(enabled){if(clipToViewport){const viewPort=renderer.renderTarget.rootViewPort;bounds.fitBounds(0,viewPort.width,0,viewPort.height)}bounds.scale(resolution).ceil().scale(1/resolution).pad(0|padding),bounds.isPositive?(filterData.skip=!1,filterData.bounds=bounds,filterData.blendRequired=blendRequired,filterData.container=instruction.container,filterData.filterEffect=instruction.filterEffect,filterData.previousRenderSurface=renderer.renderTarget.renderSurface,filterData.inputTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,resolution,antialias),renderer.renderTarget.bind(filterData.inputTexture,!0),renderer.globalUniforms.push({offset:bounds})):filterData.skip=!0}else filterData.skip=!0}pop(){const renderer=this.renderer;this._filterStackIndex--;const filterData=this._filterStack[this._filterStackIndex];if(filterData.skip)return;this._activeFilterData=filterData;const inputTexture=filterData.inputTexture,bounds=filterData.bounds;let backTexture=Texture.g.EMPTY;if(renderer.renderTarget.finishRenderPass(),filterData.blendRequired){const previousBounds=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,renderTarget=renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);backTexture=this.getBackTexture(renderTarget,bounds,previousBounds)}filterData.backTexture=backTexture;const filters=filterData.filterEffect.filters;if(this._globalFilterBindGroup.setResource(inputTexture.source.style,2),this._globalFilterBindGroup.setResource(backTexture.source,3),renderer.globalUniforms.pop(),1===filters.length)filters[0].apply(this,inputTexture,filterData.previousRenderSurface,!1),TexturePool.W.returnTexture(inputTexture);else{let flip=filterData.inputTexture,flop=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,flip.source._resolution,!1),i=0;for(i=0;i<filters.length-1;++i){filters[i].apply(this,flip,flop,!0);const t=flip;flip=flop,flop=t}filters[i].apply(this,flip,filterData.previousRenderSurface,!1),TexturePool.W.returnTexture(flip),TexturePool.W.returnTexture(flop)}filterData.blendRequired&&TexturePool.W.returnTexture(backTexture)}getBackTexture(lastRenderSurface,bounds,previousBounds){const backgroundResolution=lastRenderSurface.colorTexture.source._resolution,backTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,backgroundResolution,!1);let x=bounds.minX,y=bounds.minY;previousBounds&&(x-=previousBounds.minX,y-=previousBounds.minY),x=Math.floor(x*backgroundResolution),y=Math.floor(y*backgroundResolution);const width=Math.ceil(bounds.width*backgroundResolution),height=Math.ceil(bounds.height*backgroundResolution);return this.renderer.renderTarget.copyToTexture(lastRenderSurface,backTexture,{x,y},{width,height},{x:0,y:0}),backTexture}applyFilter(filter,input,output,clear){const renderer=this.renderer,filterData=this._filterStack[this._filterStackIndex],bounds=filterData.bounds,offset=Point.b.shared,isFinalTarget=filterData.previousRenderSurface===output;let resolution=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,currentIndex=this._filterStackIndex-1;for(;currentIndex>0&&this._filterStack[currentIndex].skip;)--currentIndex;currentIndex>0&&(resolution=this._filterStack[currentIndex].inputTexture.source._resolution);const filterUniforms=this._filterGlobalUniforms,uniforms=filterUniforms.uniforms,outputFrame=uniforms.uOutputFrame,inputSize=uniforms.uInputSize,inputPixel=uniforms.uInputPixel,inputClamp=uniforms.uInputClamp,globalFrame=uniforms.uGlobalFrame,outputTexture=uniforms.uOutputTexture;if(isFinalTarget){let lastIndex=this._filterStackIndex;for(;lastIndex>0;){lastIndex--;const filterData2=this._filterStack[this._filterStackIndex-1];if(!filterData2.skip){offset.x=filterData2.bounds.minX,offset.y=filterData2.bounds.minY;break}}outputFrame[0]=bounds.minX-offset.x,outputFrame[1]=bounds.minY-offset.y}else outputFrame[0]=0,outputFrame[1]=0;outputFrame[2]=input.frame.width,outputFrame[3]=input.frame.height,inputSize[0]=input.source.width,inputSize[1]=input.source.height,inputSize[2]=1/inputSize[0],inputSize[3]=1/inputSize[1],inputPixel[0]=input.source.pixelWidth,inputPixel[1]=input.source.pixelHeight,inputPixel[2]=1/inputPixel[0],inputPixel[3]=1/inputPixel[1],inputClamp[0]=.5*inputPixel[2],inputClamp[1]=.5*inputPixel[3],inputClamp[2]=input.frame.width*inputSize[2]-.5*inputPixel[2],inputClamp[3]=input.frame.height*inputSize[3]-.5*inputPixel[3];const rootTexture=this.renderer.renderTarget.rootRenderTarget.colorTexture;globalFrame[0]=offset.x*resolution,globalFrame[1]=offset.y*resolution,globalFrame[2]=rootTexture.source.width*resolution,globalFrame[3]=rootTexture.source.height*resolution;const renderTarget=this.renderer.renderTarget.getRenderTarget(output);if(renderer.renderTarget.bind(output,!!clear),output instanceof Texture.g?(outputTexture[0]=output.frame.width,outputTexture[1]=output.frame.height):(outputTexture[0]=renderTarget.width,outputTexture[1]=renderTarget.height),outputTexture[2]=renderTarget.isRoot?-1:1,filterUniforms.update(),renderer.renderPipes.uniformBatch){const batchUniforms=renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);this._globalFilterBindGroup.setResource(batchUniforms,0)}else this._globalFilterBindGroup.setResource(filterUniforms,0);this._globalFilterBindGroup.setResource(input.source,1),this._globalFilterBindGroup.setResource(input.source.style,2),filter.groups[0]=this._globalFilterBindGroup,renderer.encoder.draw({geometry:quadGeometry,shader:filter,state:filter._state,topology:"triangle-list"}),renderer.type===types.W.WEBGL&&renderer.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds.c,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(outputMatrix,sprite){const data=this._activeFilterData,mappedMatrix=outputMatrix.set(data.inputTexture._source.width,0,0,data.inputTexture._source.height,data.bounds.minX,data.bounds.minY),worldTransform=sprite.worldTransform.copyTo(Matrix.u.shared);return worldTransform.invert(),mappedMatrix.prepend(worldTransform),mappedMatrix.scale(1/sprite.texture.frame.width,1/sprite.texture.frame.height),mappedMatrix.translate(sprite.anchor.x,sprite.anchor.y),mappedMatrix}}FilterSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"filter"},Extensions.XO.add(FilterSystem),Extensions.XO.add(FilterPipe)},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ls:()=>localUniformBit,_Q:()=>localUniformBitGroup2,mA:()=>localUniformBitGl});const localUniformBit={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>State});const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},_State=class _State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(value){!!(1&this.data)!==value&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(value){!!(2&this.data)!==value&&(this.data^=2)}set cullMode(value){"none"!==value?(this.culling=!0,this.clockwiseFrontFace="front"===value):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(value){!!(4&this.data)!==value&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(value){!!(8&this.data)!==value&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(value){!!(32&this.data)!==value&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(value){!!(16&this.data)!==value&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(value){this.blend="none"!==value,this._blendMode=value,this._blendModeId=blendModeIds[value]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(value){this.offsets=!!value,this._polygonOffset=value}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const state=new _State;return state.depthTest=!1,state.blend=!0,state}};_State.default2d=_State.for2d();let State=_State},"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function color32BitToUniform(abgr,out,offset){const alpha=(abgr>>24&255)/255;out[offset++]=(255&abgr)/255*alpha,out[offset++]=(abgr>>8&255)/255*alpha,out[offset++]=(abgr>>16&255)/255*alpha,out[offset++]=alpha}__webpack_require__.d(__webpack_exports__,{V:()=>color32BitToUniform})},"./node_modules/pixi.js/lib/scene/graphics/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),GraphicsContextSystem=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableGraphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");class GraphicsPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this._graphicsBatchesHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init(),this.renderer.renderableGC.addManagedHash(this,"_graphicsBatchesHash")}validateRenderable(graphics){const context=graphics.context,wasBatched=!!this._graphicsBatchesHash[graphics.uid],gpuContext=this.renderer.graphicsContext.updateGpuContext(context);return!(!gpuContext.isBatchable&&wasBatched===gpuContext.isBatchable)}addRenderable(graphics,instructionSet){const gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);graphics.didViewUpdate&&this._rebuild(graphics),gpuContext.isBatchable?this._addToBatcher(graphics,instructionSet):(this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(graphics))}updateRenderable(graphics){const batches=this._graphicsBatchesHash[graphics.uid];if(batches)for(let i=0;i<batches.length;i++){const batch=batches[i];batch._batcher.updateElement(batch)}}destroyRenderable(graphics){this._graphicsBatchesHash[graphics.uid]&&this._removeBatchForRenderable(graphics.uid),graphics.off("destroyed",this._destroyRenderableBound)}execute(graphics){if(!graphics.isRenderable)return;const renderer=this.renderer,context=graphics.context;if(!renderer.graphicsContext.getGpuContext(context).batches.length)return;const shader=context.customShader||this._adaptor.shader;this.state.blendMode=graphics.groupBlendMode;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=graphics.groupTransform,localUniforms.uRound=renderer._roundPixels|graphics._roundPixels,(0,colorToUniform.V)(graphics.groupColorAlpha,localUniforms.uColor,0),this._adaptor.execute(this,graphics)}_rebuild(graphics){const wasBatched=!!this._graphicsBatchesHash[graphics.uid],gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);wasBatched&&this._removeBatchForRenderable(graphics.uid),gpuContext.isBatchable&&this._initBatchesForRenderable(graphics),graphics.batched=gpuContext.isBatchable}_addToBatcher(graphics,instructionSet){const batchPipe=this.renderer.renderPipes.batch,batches=this._getBatchesForRenderable(graphics);for(let i=0;i<batches.length;i++){const batch=batches[i];batchPipe.addToBatch(batch,instructionSet)}}_getBatchesForRenderable(graphics){return this._graphicsBatchesHash[graphics.uid]||this._initBatchesForRenderable(graphics)}_initBatchesForRenderable(graphics){const context=graphics.context,gpuContext=this.renderer.graphicsContext.getGpuContext(context),roundPixels=this.renderer._roundPixels|graphics._roundPixels,batches=gpuContext.batches.map(batch=>{const batchClone=PoolGroup.Z.get(BatchableGraphics.G);return batch.copyTo(batchClone),batchClone.renderable=graphics,batchClone.roundPixels=roundPixels,batchClone});return void 0===this._graphicsBatchesHash[graphics.uid]&&graphics.on("destroyed",this._destroyRenderableBound),this._graphicsBatchesHash[graphics.uid]=batches,batches}_removeBatchForRenderable(graphicsUid){this._graphicsBatchesHash[graphicsUid].forEach(batch=>{PoolGroup.Z.return(batch)}),this._graphicsBatchesHash[graphicsUid]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const i in this._graphicsBatchesHash)this._removeBatchForRenderable(i);this._graphicsBatchesHash=null}}GraphicsPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"graphics"},Extensions.XO.add(GraphicsPipe),Extensions.XO.add(GraphicsContextSystem.GH)},"./node_modules/pixi.js/lib/scene/mesh/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");class MeshPipe{constructor(renderer,adaptor){this.localUniforms=new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup.T({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init(),renderer.renderableGC.addManagedHash(this,"_gpuBatchableMeshHash"),renderer.renderableGC.addManagedHash(this,"_meshDataHash")}validateRenderable(mesh){const meshData=this._getMeshData(mesh),wasBatched=meshData.batched,isBatched=mesh.batched;if(meshData.batched=isBatched,wasBatched!==isBatched)return!0;if(isBatched){const geometry=mesh._geometry;if(geometry.indices.length!==meshData.indexSize||geometry.positions.length!==meshData.vertexSize)return meshData.indexSize=geometry.indices.length,meshData.vertexSize=geometry.positions.length,!0;const batchableMesh=this._getBatchableMesh(mesh),texture=mesh.texture;if(batchableMesh.texture._source!==texture._source&&batchableMesh.texture._source!==texture._source)return!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,texture)}return!1}addRenderable(mesh,instructionSet){const batcher=this.renderer.renderPipes.batch,{batched}=this._getMeshData(mesh);if(batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.texture=mesh._texture,gpuBatchableMesh.geometry=mesh._geometry,batcher.addToBatch(gpuBatchableMesh,instructionSet)}else batcher.break(instructionSet),instructionSet.add(mesh)}updateRenderable(mesh){if(mesh.batched){const gpuBatchableMesh=this._gpuBatchableMeshHash[mesh.uid];gpuBatchableMesh.texture=mesh._texture,gpuBatchableMesh.geometry=mesh._geometry,gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh)}}destroyRenderable(mesh){this._meshDataHash[mesh.uid]=null;const gpuMesh=this._gpuBatchableMeshHash[mesh.uid];gpuMesh&&(PoolGroup.Z.return(gpuMesh),this._gpuBatchableMeshHash[mesh.uid]=null),mesh.off("destroyed",this._destroyRenderableBound)}execute(mesh){if(!mesh.isRenderable)return;mesh.state.blendMode=(0,getAdjustedBlendModeBlend.i)(mesh.groupBlendMode,mesh.texture._source);const localUniforms=this.localUniforms;localUniforms.uniforms.uTransformMatrix=mesh.groupTransform,localUniforms.uniforms.uRound=this.renderer._roundPixels|mesh._roundPixels,localUniforms.update(),(0,colorToUniform.V)(mesh.groupColorAlpha,localUniforms.uniforms.uColor,0),this._adaptor.execute(this,mesh)}_getMeshData(mesh){return this._meshDataHash[mesh.uid]||this._initMeshData(mesh)}_initMeshData(mesh){return this._meshDataHash[mesh.uid]={batched:mesh.batched,indexSize:mesh._geometry.indices?.length,vertexSize:mesh._geometry.positions?.length},mesh.on("destroyed",this._destroyRenderableBound),this._meshDataHash[mesh.uid]}_getBatchableMesh(mesh){return this._gpuBatchableMeshHash[mesh.uid]||this._initBatchableMesh(mesh)}_initBatchableMesh(mesh){const gpuMesh=PoolGroup.Z.get(BatchableMesh.U);return gpuMesh.renderable=mesh,gpuMesh.texture=mesh._texture,gpuMesh.transform=mesh.groupTransform,gpuMesh.roundPixels=this.renderer._roundPixels|mesh._roundPixels,this._gpuBatchableMeshHash[mesh.uid]=gpuMesh,gpuMesh}destroy(){for(const i in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[i]&&PoolGroup.Z.return(this._gpuBatchableMeshHash[i]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"mesh"},Extensions.XO.add(MeshPipe)},"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>BatchableMesh});class BatchableMesh{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(value){this._topology=value}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}get uvs(){const uvBuffer=this.geometry.getBuffer("aUV"),uvs=uvBuffer.data;let transformedUvs=uvs;const textureMatrix=this.texture.textureMatrix;return textureMatrix.isSimple||(transformedUvs=this._transformedUvs,this._textureMatrixUpdateId===textureMatrix._updateID&&this._uvUpdateId===uvBuffer._updateID||((!transformedUvs||transformedUvs.length<uvs.length)&&(transformedUvs=this._transformedUvs=new Float32Array(uvs.length)),this._textureMatrixUpdateId=textureMatrix._updateID,this._uvUpdateId=uvBuffer._updateID,textureMatrix.multiplyUvs(uvs,transformedUvs))),transformedUvs}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},"./node_modules/pixi.js/lib/scene/particle-container/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class GlParticleContainerAdaptor{execute(particleContainerPipe,container){const state=particleContainerPipe.state,renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.resources.uTexture=container.texture._source,shader.resources.uniforms=particleContainerPipe.localUniforms;const gl=renderer.gl,buffer=particleContainerPipe.getBuffers(container);renderer.shader.bind(shader),renderer.state.set(state),renderer.geometry.bind(buffer.geometry,shader.glProgram);const glType=2===buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT?gl.UNSIGNED_SHORT:gl.UNSIGNED_INT;gl.drawElements(gl.TRIANGLES,6*container.particleChildren.length,glType,0)}}var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),Buffer=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),buffer_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"),Geometry=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),getAttributeInfoFromFormat=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"),ViewableBuffer=__webpack_require__("./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs");function createIndicesForQuads(size,outBuffer=null){const totalIndices=6*size;if(totalIndices>65535?outBuffer||(outBuffer=new Uint32Array(totalIndices)):outBuffer||(outBuffer=new Uint16Array(totalIndices)),outBuffer.length!==totalIndices)throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);for(let i=0,j=0;i<totalIndices;i+=6,j+=4)outBuffer[i+0]=j+0,outBuffer[i+1]=j+1,outBuffer[i+2]=j+2,outBuffer[i+3]=j+0,outBuffer[i+4]=j+2,outBuffer[i+5]=j+3;return outBuffer}function generateUpdateFunction(properties,dynamic){const funcFragments=[];funcFragments.push("\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            ");let offset=0;for(const i in properties){const property=properties[i];if(dynamic!==property.dynamic)continue;funcFragments.push(`offset = index + ${offset}`),funcFragments.push(property.code);offset+=(0,getAttributeInfoFromFormat.m)(property.format).stride/4}funcFragments.push("\n            index += stride * 4;\n        }\n    "),funcFragments.unshift(`\n        var stride = ${offset};\n    `);const functionSource=funcFragments.join("\n");return new Function("ps","f32v","u32v",functionSource)}class ParticleBuffer{constructor(options){this._size=0,this._generateParticleUpdateCache={};const size=this._size=options.size??1e3,properties=options.properties;let staticVertexSize=0,dynamicVertexSize=0;for(const i in properties){const property=properties[i],attributeInfo=(0,getAttributeInfoFromFormat.m)(property.format);property.dynamic?dynamicVertexSize+=attributeInfo.stride:staticVertexSize+=attributeInfo.stride}this._dynamicStride=dynamicVertexSize/4,this._staticStride=staticVertexSize/4,this.staticAttributeBuffer=new ViewableBuffer.u(4*size*staticVertexSize),this.dynamicAttributeBuffer=new ViewableBuffer.u(4*size*dynamicVertexSize),this.indexBuffer=createIndicesForQuads(size);const geometry=new Geometry.V;let dynamicOffset=0,staticOffset=0;this._staticBuffer=new Buffer.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:buffer_const.S.VERTEX|buffer_const.S.COPY_DST}),this._dynamicBuffer=new Buffer.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:buffer_const.S.VERTEX|buffer_const.S.COPY_DST});for(const i in properties){const property=properties[i],attributeInfo=(0,getAttributeInfoFromFormat.m)(property.format);property.dynamic?(geometry.addAttribute(property.attributeName,{buffer:this._dynamicBuffer,stride:4*this._dynamicStride,offset:4*dynamicOffset,format:property.format}),dynamicOffset+=attributeInfo.size):(geometry.addAttribute(property.attributeName,{buffer:this._staticBuffer,stride:4*this._staticStride,offset:4*staticOffset,format:property.format}),staticOffset+=attributeInfo.size)}geometry.addIndex(this.indexBuffer);const uploadFunction=this.getParticleUpdate(properties);this._dynamicUpload=uploadFunction.dynamicUpdate,this._staticUpload=uploadFunction.staticUpdate,this.geometry=geometry}getParticleUpdate(properties){const key=function getParticleSyncKey(properties){const keyGen=[];for(const key in properties){const property=properties[key];keyGen.push(key,property.code,property.dynamic?"d":"s")}return keyGen.join("_")}(properties);return this._generateParticleUpdateCache[key]||(this._generateParticleUpdateCache[key]=this.generateParticleUpdate(properties)),this._generateParticleUpdateCache[key]}generateParticleUpdate(properties){return function generateParticleUpdateFunction(properties){return{dynamicUpdate:generateUpdateFunction(properties,!0),staticUpdate:generateUpdateFunction(properties,!1)}}(properties)}update(particles,uploadStatic){particles.length>this._size&&(uploadStatic=!0,this._size=Math.max(particles.length,1.5*this._size|0),this.staticAttributeBuffer=new ViewableBuffer.u(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new ViewableBuffer.u(this._size*this._dynamicStride*4*4),this.indexBuffer=createIndicesForQuads(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const dynamicAttributeBuffer=this.dynamicAttributeBuffer;if(this._dynamicUpload(particles,dynamicAttributeBuffer.float32View,dynamicAttributeBuffer.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,particles.length*this._dynamicStride*4,!0),uploadStatic){const staticAttributeBuffer=this.staticAttributeBuffer;this._staticUpload(particles,staticAttributeBuffer.float32View,staticAttributeBuffer.uint32View),this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View,particles.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}var Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),GlProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),GpuProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TextureStyle=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"),wgsl="\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uResolution:vec2<f32>,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class ParticleShader extends Shader.M{constructor(){super({glProgram:GlProgram.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:GpuProgram.B.from({fragment:{source:wgsl,entryPoint:"mainFragment"},vertex:{source:wgsl,entryPoint:"mainVertex"}}),resources:{uTexture:Texture.g.WHITE.source,uSampler:new TextureStyle.n({}),uniforms:{uTranslationMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Color.Q(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ParticleContainerPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this._gpuBufferHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.localUniforms=new UniformGroup.k({uTranslationMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=renderer,this.adaptor=adaptor,this.defaultShader=new ParticleShader,this.state=State.U.for2d()}validateRenderable(_renderable){return!1}addRenderable(renderable,instructionSet){this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(renderable)}getBuffers(renderable){return this._gpuBufferHash[renderable.uid]||this._initBuffer(renderable)}_initBuffer(renderable){return this._gpuBufferHash[renderable.uid]=new ParticleBuffer({size:renderable.particleChildren.length,properties:renderable._properties}),renderable.on("destroyed",this._destroyRenderableBound),this._gpuBufferHash[renderable.uid]}updateRenderable(_renderable){}destroyRenderable(renderable){this._gpuBufferHash[renderable.uid].destroy(),this._gpuBufferHash[renderable.uid]=null,renderable.off("destroyed",this._destroyRenderableBound)}execute(container){const children=container.particleChildren;if(0===children.length)return;const renderer=this.renderer,buffer=this.getBuffers(container);container.texture||(container.texture=children[0].texture);const state=this.state;buffer.update(children,container._childrenDirty),container._childrenDirty=!1,state.blendMode=(0,getAdjustedBlendModeBlend.i)(container.blendMode,container.texture._source);const uniforms=this.localUniforms.uniforms,transformationMatrix=uniforms.uTranslationMatrix;container.worldTransform.copyTo(transformationMatrix),transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix),uniforms.uResolution=renderer.globalUniforms.globalUniformData.resolution,uniforms.uRound=renderer._roundPixels|container._roundPixels,(0,colorToUniform.V)(container.groupColorAlpha,uniforms.uColor,0),this.adaptor.execute(this,container)}destroy(){this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class GlParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GlParticleContainerAdaptor)}}GlParticleContainerPipe.extension={type:[Extensions.Ag.WebGLPipes],name:"particle"};class GpuParticleContainerAdaptor{execute(particleContainerPipe,container){const renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.groups[0]=renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms,!0),shader.groups[1]=renderer.texture.getTextureBindGroup(container.texture);const state=particleContainerPipe.state,buffer=particleContainerPipe.getBuffers(container);renderer.encoder.draw({geometry:buffer.geometry,shader:container.shader||particleContainerPipe.defaultShader,state,size:6*container.particleChildren.length})}}class GpuParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GpuParticleContainerAdaptor)}}GpuParticleContainerPipe.extension={type:[Extensions.Ag.WebGPUPipes],name:"particle"},Extensions.XO.add(GlParticleContainerPipe),Extensions.XO.add(GpuParticleContainerPipe)},"./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),NineSliceGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs");class NineSliceSpritePipe{constructor(renderer){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(sprite,instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite,instructionSet)}updateRenderable(sprite){const gpuSprite=this._gpuSpriteHash[sprite.uid];sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite._batcher.updateElement(gpuSprite)}validateRenderable(sprite){const texture=sprite._texture,gpuSprite=this._getGpuSprite(sprite);return gpuSprite.texture._source!==texture._source&&!gpuSprite._batcher.checkAndUpdateTexture(gpuSprite,texture)}destroyRenderable(sprite){const batchableMesh=this._gpuSpriteHash[sprite.uid];PoolGroup.Z.return(batchableMesh.geometry),PoolGroup.Z.return(batchableMesh),this._gpuSpriteHash[sprite.uid]=null,sprite.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(sprite,batchableSprite){batchableSprite.geometry.update(sprite),batchableSprite.texture=sprite._texture}_getGpuSprite(sprite){return this._gpuSpriteHash[sprite.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const batchableMesh=PoolGroup.Z.get(BatchableMesh.U);return batchableMesh.geometry=PoolGroup.Z.get(NineSliceGeometry.P),batchableMesh.renderable=sprite,batchableMesh.transform=sprite.groupTransform,batchableMesh.texture=sprite._texture,batchableMesh.roundPixels=this._renderer._roundPixels|sprite._roundPixels,this._gpuSpriteHash[sprite.uid]=batchableMesh,sprite.didViewUpdate||this._updateBatchableSprite(sprite,batchableMesh),sprite.on("destroyed",this._destroyRenderableBound),batchableMesh}destroy(){for(const i in this._gpuSpriteHash){this._gpuSpriteHash[i].geometry.destroy()}this._gpuSpriteHash=null,this._renderer=null}}NineSliceSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"nineSliceSprite"},Extensions.XO.add(NineSliceSpritePipe)},"./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),MeshGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),localUniformBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");const tilingBit={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},tilingBitGl={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        "}};let gpuProgram,glProgram;class TilingSpriteShader extends Shader.M{constructor(){gpuProgram??(gpuProgram=(0,compileHighShaderToProgram.v)({name:"tiling-sprite-shader",bits:[localUniformBit.Ls,tilingBit,roundPixelsBit.b]})),glProgram??(glProgram=(0,compileHighShaderToProgram.I)({name:"tiling-sprite-shader",bits:[localUniformBit.mA,tilingBitGl,roundPixelsBit.m]}));const tilingUniforms=new UniformGroup.k({uMapCoord:{value:new Matrix.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram,gpuProgram,resources:{localUniforms:new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms,uTexture:Texture.g.EMPTY.source,uSampler:Texture.g.EMPTY.source.style}})}updateUniforms(width,height,matrix,anchorX,anchorY,texture){const tilingUniforms=this.resources.tilingUniforms,textureWidth=texture.width,textureHeight=texture.height,textureMatrix=texture.textureMatrix,uTextureTransform=tilingUniforms.uniforms.uTextureTransform;uTextureTransform.set(matrix.a*textureWidth/width,matrix.b*textureWidth/height,matrix.c*textureHeight/width,matrix.d*textureHeight/height,matrix.tx/width,matrix.ty/height),uTextureTransform.invert(),tilingUniforms.uniforms.uMapCoord=textureMatrix.mapCoord,tilingUniforms.uniforms.uClampFrame=textureMatrix.uClampFrame,tilingUniforms.uniforms.uClampOffset=textureMatrix.uClampOffset,tilingUniforms.uniforms.uTextureTransform=uTextureTransform,tilingUniforms.uniforms.uSizeAnchor[0]=width,tilingUniforms.uniforms.uSizeAnchor[1]=height,tilingUniforms.uniforms.uSizeAnchor[2]=anchorX,tilingUniforms.uniforms.uSizeAnchor[3]=anchorY,texture&&(this.resources.uTexture=texture.source,this.resources.uSampler=texture.source.style)}}class QuadGeometry extends MeshGeometry.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const sharedQuad=new QuadGeometry;class TilingSpritePipe{constructor(renderer){this._state=State.U.default2d,this._tilingSpriteDataHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_tilingSpriteDataHash")}validateRenderable(renderable){const tilingSpriteData=this._getTilingSpriteData(renderable),couldBatch=tilingSpriteData.canBatch;this._updateCanBatch(renderable);const canBatch=tilingSpriteData.canBatch;if(canBatch&&canBatch===couldBatch){const{batchableMesh}=tilingSpriteData;if(batchableMesh&&batchableMesh.texture._source!==renderable.texture._source)return!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,renderable.texture)}return couldBatch!==canBatch}addRenderable(tilingSprite,instructionSet){const batcher=this._renderer.renderPipes.batch;this._updateCanBatch(tilingSprite);const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{geometry,canBatch}=tilingSpriteData;if(canBatch){tilingSpriteData.batchableMesh||(tilingSpriteData.batchableMesh=new BatchableMesh.U);const batchableMesh=tilingSpriteData.batchableMesh;tilingSprite.didViewUpdate&&(this._updateBatchableMesh(tilingSprite),batchableMesh.geometry=geometry,batchableMesh.renderable=tilingSprite,batchableMesh.transform=tilingSprite.groupTransform,batchableMesh.texture=tilingSprite._texture),batchableMesh.roundPixels=this._renderer._roundPixels|tilingSprite._roundPixels,batcher.addToBatch(batchableMesh,instructionSet)}else batcher.break(instructionSet),tilingSpriteData.shader||(tilingSpriteData.shader=new TilingSpriteShader),this.updateRenderable(tilingSprite),instructionSet.add(tilingSprite)}execute(tilingSprite){const{shader}=this._tilingSpriteDataHash[tilingSprite.uid];shader.groups[0]=this._renderer.globalUniforms.bindGroup;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=tilingSprite.groupTransform,localUniforms.uRound=this._renderer._roundPixels|tilingSprite._roundPixels,(0,colorToUniform.V)(tilingSprite.groupColorAlpha,localUniforms.uColor,0),this._state.blendMode=(0,getAdjustedBlendModeBlend.i)(tilingSprite.groupBlendMode,tilingSprite.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader,state:this._state})}updateRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{canBatch}=tilingSpriteData;if(canBatch){const{batchableMesh}=tilingSpriteData;tilingSprite.didViewUpdate&&this._updateBatchableMesh(tilingSprite),batchableMesh._batcher.updateElement(batchableMesh)}else if(tilingSprite.didViewUpdate){const{shader}=tilingSpriteData;shader.updateUniforms(tilingSprite.width,tilingSprite.height,tilingSprite._tileTransform.matrix,tilingSprite.anchor.x,tilingSprite.anchor.y,tilingSprite.texture)}}destroyRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite);tilingSpriteData.batchableMesh=null,tilingSpriteData.shader?.destroy(),this._tilingSpriteDataHash[tilingSprite.uid]=null,tilingSprite.off("destroyed",this._destroyRenderableBound)}_getTilingSpriteData(renderable){return this._tilingSpriteDataHash[renderable.uid]||this._initTilingSpriteData(renderable)}_initTilingSpriteData(tilingSprite){const geometry=new MeshGeometry.u({indices:sharedQuad.indices,positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()});return this._tilingSpriteDataHash[tilingSprite.uid]={canBatch:!0,renderable:tilingSprite,geometry},tilingSprite.on("destroyed",this._destroyRenderableBound),this._tilingSpriteDataHash[tilingSprite.uid]}_updateBatchableMesh(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),{geometry}=renderableData,style=tilingSprite.texture.source.style;"repeat"!==style.addressMode&&(style.addressMode="repeat",style.update()),function setUvs(tilingSprite,uvs){const texture=tilingSprite.texture,width=texture.frame.width,height=texture.frame.height;let anchorX=0,anchorY=0;tilingSprite.applyAnchorToTexture&&(anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y),uvs[0]=uvs[6]=-anchorX,uvs[2]=uvs[4]=1-anchorX,uvs[1]=uvs[3]=-anchorY,uvs[5]=uvs[7]=1-anchorY;const textureMatrix=Matrix.u.shared;textureMatrix.copyFrom(tilingSprite._tileTransform.matrix),textureMatrix.tx/=tilingSprite.width,textureMatrix.ty/=tilingSprite.height,textureMatrix.invert(),textureMatrix.scale(tilingSprite.width/width,tilingSprite.height/height),function applyMatrix(array,stride,offset,matrix){let index=0;const size=array.length/(stride||2),a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;for(offset*=stride;index<size;){const x=array[offset],y=array[offset+1];array[offset]=a*x+c*y+tx,array[offset+1]=b*x+d*y+ty,offset+=stride,index++}}(uvs,2,0,textureMatrix)}(tilingSprite,geometry.uvs),function setPositions(tilingSprite,positions){const anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y;positions[0]=-anchorX*tilingSprite.width,positions[1]=-anchorY*tilingSprite.height,positions[2]=(1-anchorX)*tilingSprite.width,positions[3]=-anchorY*tilingSprite.height,positions[4]=(1-anchorX)*tilingSprite.width,positions[5]=(1-anchorY)*tilingSprite.height,positions[6]=-anchorX*tilingSprite.width,positions[7]=(1-anchorY)*tilingSprite.height}(tilingSprite,geometry.positions)}destroy(){for(const i in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),texture=tilingSprite.texture;let _nonPowOf2wrapping=!0;return this._renderer.type===types.W.WEBGL&&(_nonPowOf2wrapping=this._renderer.context.supports.nonPowOf2wrapping),renderableData.canBatch=texture.textureMatrix.isSimple&&(_nonPowOf2wrapping||texture.source.isPowerOfTwo),renderableData.canBatch}}TilingSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"tilingSprite"},Extensions.XO.add(TilingSpritePipe)},"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{K:()=>BatchableSprite});class BatchableSprite{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}}},"./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),Graphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),maxRecommendedTextures=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),colorBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"),generateTextureBatchBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),getBatchSamplersUniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:" \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        "}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:" \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        "}},mSDFBit={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        "}},mSDFBitGl={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        "}};let gpuProgram,glProgram;class SdfShader extends Shader.M{constructor(){const uniforms=new UniformGroup.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),maxTextures=(0,maxRecommendedTextures.a)();gpuProgram??(gpuProgram=(0,compileHighShaderToProgram.v)({name:"sdf-shader",bits:[colorBit.F,(0,generateTextureBatchBit._)(maxTextures),localUniformMSDFBit,mSDFBit,roundPixelsBit.b]})),glProgram??(glProgram=(0,compileHighShaderToProgram.I)({name:"sdf-shader",bits:[colorBit.a,(0,generateTextureBatchBit.P)(maxTextures),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBit.m]})),super({glProgram,gpuProgram,resources:{localUniforms:uniforms,batchSamplers:(0,getBatchSamplersUniformGroup.n)(maxTextures)}})}}var BitmapFontManager=__webpack_require__("./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"),getBitmapTextLayout=__webpack_require__("./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs");class BitmapTextPipe{constructor(renderer){this._gpuBitmapText={},this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_gpuBitmapText")}validateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);return bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable)}addRenderable(bitmapText,instructionSet){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable,instructionSet),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}destroyRenderable(bitmapText){bitmapText.off("destroyed",this._destroyRenderableBound),this._destroyRenderableByUid(bitmapText.uid)}_destroyRenderableByUid(renderableUid){const context=this._gpuBitmapText[renderableUid].context;context.customShader&&(PoolGroup.Z.return(context.customShader),context.customShader=null),PoolGroup.Z.return(this._gpuBitmapText[renderableUid]),this._gpuBitmapText[renderableUid]=null}updateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}_updateContext(bitmapText,proxyGraphics){const{context}=proxyGraphics,bitmapFont=BitmapFontManager.c.getFont(bitmapText.text,bitmapText._style);context.clear(),"none"!==bitmapFont.distanceField.type&&(context.customShader||(context.customShader=PoolGroup.Z.get(SdfShader)));const chars=Array.from(bitmapText.text),style=bitmapText._style;let currentY=bitmapFont.baseLineOffset;const bitmapTextLayout=(0,getBitmapTextLayout.Z)(chars,style,bitmapFont,!0);let index=0;const padding=style.padding,scale=bitmapTextLayout.scale;let tx=bitmapTextLayout.width,ty=bitmapTextLayout.height+bitmapTextLayout.offsetY;style._stroke&&(tx+=style._stroke.width/scale,ty+=style._stroke.width/scale),context.translate(-bitmapText._anchor._x*tx-padding,-bitmapText._anchor._y*ty-padding).scale(scale,scale);const tint=bitmapFont.applyFillAsTint?style._fill.color:16777215;for(let i=0;i<bitmapTextLayout.lines.length;i++){const line=bitmapTextLayout.lines[i];for(let j=0;j<line.charPositions.length;j++){const char=chars[index++],charData=bitmapFont.chars[char];charData?.texture&&context.texture(charData.texture,tint||"black",Math.round(line.charPositions[j]+charData.xOffset),Math.round(currentY+charData.yOffset))}currentY+=bitmapFont.lineHeight}}_getGpuBitmapText(bitmapText){return this._gpuBitmapText[bitmapText.uid]||this.initGpuText(bitmapText)}initGpuText(bitmapText){const proxyRenderable=PoolGroup.Z.get(Graphics.A);return this._gpuBitmapText[bitmapText.uid]=proxyRenderable,this._updateContext(bitmapText,proxyRenderable),bitmapText.on("destroyed",this._destroyRenderableBound),this._gpuBitmapText[bitmapText.uid]}_updateDistanceField(bitmapText){const context=this._getGpuBitmapText(bitmapText).context,fontFamily=bitmapText._style.fontFamily,dynamicFont=Cache.l.get(`${fontFamily}-bitmap`),{a,b,c,d}=bitmapText.groupTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=dynamicFont.baseRenderedFontSize/bitmapText._style.fontSize,distance=worldScale*dynamicFont.distanceField.range*(1/fontScale);context.customShader.resources.localUniforms.uniforms.uDistance=distance}destroy(){for(const uid in this._gpuBitmapText)this._destroyRenderableByUid(uid);this._gpuBitmapText=null,this._renderer=null}}function syncWithProxy(container,proxy){proxy.groupTransform=container.groupTransform,proxy.groupColorAlpha=container.groupColorAlpha,proxy.groupColor=container.groupColor,proxy.groupBlendMode=container.groupBlendMode,proxy.globalDisplayStatus=container.globalDisplayStatus,proxy.groupTransform=container.groupTransform,proxy.localDisplayStatus=container.localDisplayStatus,proxy.groupAlpha=container.groupAlpha,proxy._roundPixels=container._roundPixels}BitmapTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"bitmapText"},Extensions.XO.add(BitmapTextPipe)},"./node_modules/pixi.js/lib/scene/text-html/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),updateQuadBounds=__webpack_require__("./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class HTMLTextPipe{constructor(renderer){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const i in this._gpuText){const gpuText=this._gpuText[i];if(!gpuText)continue;const text=gpuText.batchableSprite.renderable;text._autoResolution&&(text._resolution=this._renderer.resolution,text.onViewUpdate())}}validateRenderable(htmlText){const gpuText=this._getGpuText(htmlText),newKey=htmlText._getKey();return gpuText.textureNeedsUploading?(gpuText.textureNeedsUploading=!1,!0):gpuText.currentKey!==newKey}addRenderable(htmlText,instructionSet){const batchableSprite=this._getGpuText(htmlText).batchableSprite;htmlText._didTextUpdate&&this._updateText(htmlText),this._renderer.renderPipes.batch.addToBatch(batchableSprite,instructionSet)}updateRenderable(htmlText){const batchableSprite=this._getGpuText(htmlText).batchableSprite;htmlText._didTextUpdate&&this._updateText(htmlText),batchableSprite._batcher.updateElement(batchableSprite)}destroyRenderable(htmlText){htmlText.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(htmlText.uid)}_destroyRenderableById(htmlTextUid){const gpuText=this._gpuText[htmlTextUid];this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey),PoolGroup.Z.return(gpuText.batchableSprite),this._gpuText[htmlTextUid]=null}_updateText(htmlText){const newKey=htmlText._getKey(),gpuText=this._getGpuText(htmlText),batchableSprite=gpuText.batchableSprite;gpuText.currentKey!==newKey&&this._updateGpuText(htmlText).catch(e=>{console.error(e)}),htmlText._didTextUpdate=!1;const padding=htmlText._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,htmlText._anchor,batchableSprite.texture,padding)}async _updateGpuText(htmlText){htmlText._didTextUpdate=!1;const gpuText=this._getGpuText(htmlText);if(gpuText.generatingTexture)return;const newKey=htmlText._getKey();this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey),gpuText.generatingTexture=!0,gpuText.currentKey=newKey;const resolution=htmlText.resolution??this._renderer.resolution,texture=await this._renderer.htmlText.getManagedTexture(htmlText.text,resolution,htmlText._style,htmlText._getKey()),batchableSprite=gpuText.batchableSprite;batchableSprite.texture=gpuText.texture=texture,gpuText.generatingTexture=!1,gpuText.textureNeedsUploading=!0,htmlText.onViewUpdate();const padding=htmlText._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,htmlText._anchor,batchableSprite.texture,padding)}_getGpuText(htmlText){return this._gpuText[htmlText.uid]||this.initGpuText(htmlText)}initGpuText(htmlText){const gpuTextData={texture:Texture.g.EMPTY,currentKey:"--",batchableSprite:PoolGroup.Z.get(BatchableSprite.K),textureNeedsUploading:!1,generatingTexture:!1},batchableSprite=gpuTextData.batchableSprite;return batchableSprite.renderable=htmlText,batchableSprite.transform=htmlText.groupTransform,batchableSprite.texture=Texture.g.EMPTY,batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableSprite.roundPixels=this._renderer._roundPixels|htmlText._roundPixels,htmlText._resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution,this._gpuText[htmlText.uid]=gpuTextData,htmlText.on("destroyed",this._destroyRenderableBound),gpuTextData}destroy(){for(const i in this._gpuText)this._destroyRenderableById(i);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"htmlText"};var CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs");var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"),HTMLTextRenderData=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"),HtmlTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs");var Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs");async function loadFontCSS(style,url){const dataSrc=await async function loadFontAsBase64(url){const response=await adapter.e.get().fetch(url),blob=await response.blob(),reader=new FileReader;return await new Promise((resolve,reject)=>{reader.onloadend=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)})}(url);return`@font-face {\n        font-family: "${style.fontFamily}";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`}const FontStylePromiseCache=new Map;var measureHtmlText=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs");class HTMLTextSystem{constructor(renderer){this._activeTextures={},this._renderer=renderer,this._createCanvas=renderer.type===types.W.WEBGPU}getTexture(options){return this._buildTexturePromise(options.text,options.resolution,options.style)}getManagedTexture(text,resolution,style,textKey){if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].promise;const promise=this._buildTexturePromise(text,resolution,style).then(texture=>(this._activeTextures[textKey].texture=texture,texture));return this._activeTextures[textKey]={texture:null,promise,usageCount:1},promise}async _buildTexturePromise(text,resolution,style){const htmlTextData=PoolGroup.Z.get(HTMLTextRenderData.pF),fontFamilies=function extractFontFamilies(text,style){const fontFamily=style.fontFamily,fontFamilies=[],dedupe={},matches=text.match(/font-family:([^;"\s]+)/g);function addFontFamily(fontFamily2){dedupe[fontFamily2]||(fontFamilies.push(fontFamily2),dedupe[fontFamily2]=!0)}if(Array.isArray(fontFamily))for(let i=0;i<fontFamily.length;i++)addFontFamily(fontFamily[i]);else addFontFamily(fontFamily);matches&&matches.forEach(match=>{addFontFamily(match.split(":")[1].trim())});for(const i in style.tagStyles)addFontFamily(style.tagStyles[i].fontFamily);return fontFamilies}(text,style),fontCSS=await async function getFontCss(fontFamilies,style,defaultOptions){const fontPromises=fontFamilies.filter(fontFamily=>Cache.l.has(`${fontFamily}-and-url`)).map((fontFamily,i)=>{if(!FontStylePromiseCache.has(fontFamily)){const{url}=Cache.l.get(`${fontFamily}-and-url`);0===i?FontStylePromiseCache.set(fontFamily,loadFontCSS({fontWeight:style.fontWeight,fontStyle:style.fontStyle,fontFamily},url)):FontStylePromiseCache.set(fontFamily,loadFontCSS({fontWeight:defaultOptions.fontWeight,fontStyle:defaultOptions.fontStyle,fontFamily},url))}return FontStylePromiseCache.get(fontFamily)});return(await Promise.all(fontPromises)).join("\n")}(fontFamilies,style,HtmlTextStyle.I.defaultTextStyle),measured=(0,measureHtmlText.r)(text,style,fontCSS,htmlTextData),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution),image=htmlTextData.image;image.width=2+(0|width),image.height=2+(0|height);const svgURL=function getSVGUrl(text,style,resolution,fontCSS,htmlTextData){const{domElement,styleElement,svgRoot}=htmlTextData;domElement.innerHTML=`<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`,domElement.setAttribute("style",`transform: scale(${resolution});transform-origin: top left; display: inline-block`),styleElement.textContent=fontCSS;const{width,height}=htmlTextData.image;return svgRoot.setAttribute("width",width.toString()),svgRoot.setAttribute("height",height.toString()),(new XMLSerializer).serializeToString(svgRoot)}(text,style,resolution,fontCSS,htmlTextData);await function loadSVGImage(image,url,delay){return new Promise(async resolve=>{delay&&await new Promise(resolve2=>setTimeout(resolve2,100)),image.onload=()=>{resolve()},image.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`,image.crossOrigin="anonymous"})}(image,svgURL,function isSafari(){const{userAgent}=adapter.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(userAgent)}()&&fontFamilies.length>0);const resource=image;let canvasAndContext;this._createCanvas&&(canvasAndContext=function getTemporaryCanvasFromImage(image,resolution){const canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(image.width,image.height,resolution),{context}=canvasAndContext;return context.clearRect(0,0,image.width,image.height),context.drawImage(image,0,0),canvasAndContext}(image,resolution));const texture=(0,getPo2TextureFromSource.M)(canvasAndContext?canvasAndContext.canvas:resource,image.width-2,image.height-2,resolution);return this._createCanvas&&(this._renderer.texture.initSource(texture.source),CanvasPool.N.returnCanvasAndContext(canvasAndContext)),PoolGroup.Z.return(htmlTextData),texture}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];activeTexture&&(activeTexture.usageCount--,0===activeTexture.usageCount&&(activeTexture.texture?this._cleanUp(activeTexture):activeTexture.promise.then(texture=>{activeTexture.texture=texture,this._cleanUp(activeTexture)}).catch(()=>{(0,warn.R)("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[textKey]=null))}_cleanUp(activeTexture){TexturePool.W.returnTexture(activeTexture.texture),activeTexture.texture.source.resource=null,activeTexture.texture.source.uploadMethodId="unknown"}getReferenceCount(textKey){return this._activeTextures[textKey].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"htmlText"},HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"},Extensions.XO.add(HTMLTextSystem),Extensions.XO.add(HTMLTextPipe)},"./node_modules/pixi.js/lib/scene/text/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),updateQuadBounds=__webpack_require__("./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class CanvasTextPipe{constructor(renderer){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const i in this._gpuText){const gpuText=this._gpuText[i];if(!gpuText)continue;const text=gpuText.batchableSprite.renderable;text._autoResolution&&(text._resolution=this._renderer.resolution,text.onViewUpdate())}}validateRenderable(text){const gpuText=this._getGpuText(text),newKey=text._getKey();return gpuText.currentKey!==newKey}addRenderable(text,instructionSet){const batchableSprite=this._getGpuText(text).batchableSprite;text._didTextUpdate&&this._updateText(text),this._renderer.renderPipes.batch.addToBatch(batchableSprite,instructionSet)}updateRenderable(text){const batchableSprite=this._getGpuText(text).batchableSprite;text._didTextUpdate&&this._updateText(text),batchableSprite._batcher.updateElement(batchableSprite)}destroyRenderable(text){text.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(text.uid)}_destroyRenderableById(textUid){const gpuText=this._gpuText[textUid];this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey),PoolGroup.Z.return(gpuText.batchableSprite),this._gpuText[textUid]=null}_updateText(text){const newKey=text._getKey(),gpuText=this._getGpuText(text),batchableSprite=gpuText.batchableSprite;gpuText.currentKey!==newKey&&this._updateGpuText(text),text._didTextUpdate=!1;const padding=text._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,text._anchor,batchableSprite.texture,padding)}_updateGpuText(text){const gpuText=this._getGpuText(text),batchableSprite=gpuText.batchableSprite;gpuText.texture&&this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey),gpuText.texture=batchableSprite.texture=this._renderer.canvasText.getManagedTexture(text),gpuText.currentKey=text._getKey(),batchableSprite.texture=gpuText.texture}_getGpuText(text){return this._gpuText[text.uid]||this.initGpuText(text)}initGpuText(text){const gpuTextData={texture:null,currentKey:"--",batchableSprite:PoolGroup.Z.get(BatchableSprite.K)};return gpuTextData.batchableSprite.renderable=text,gpuTextData.batchableSprite.transform=text.groupTransform,gpuTextData.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},gpuTextData.batchableSprite.roundPixels=this._renderer._roundPixels|text._roundPixels,this._gpuText[text.uid]=gpuTextData,text._resolution=text._autoResolution?this._renderer.resolution:text.resolution,this._updateText(text),text.on("destroyed",this._destroyRenderableBound),gpuTextData}destroy(){for(const i in this._gpuText)this._destroyRenderableById(i);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"text"};var Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),pow2=__webpack_require__("./node_modules/pixi.js/lib/maths/misc/pow2.mjs"),CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");function checkRow(data,width,y){for(let x=0,index=4*y*width;x<width;++x,index+=4)if(0!==data[index+3])return!1;return!0}function checkColumn(data,width,x,top,bottom){const stride=4*width;for(let y=top,index=top*stride+4*x;y<=bottom;++y,index+=stride)if(0!==data[index+3])return!1;return!0}var deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),TextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/TextStyle.mjs"),getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"),CanvasTextMetrics=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"),fontStringFromTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"),getCanvasFillStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");class CanvasTextSystem{constructor(_renderer){this._activeTextures={},this._renderer=_renderer}getTextureSize(text,resolution,style){const measured=CanvasTextMetrics.P.measureText(text||" ",style);let width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution);return width=Math.ceil(width-1e-6),height=Math.ceil(height-1e-6),width=(0,pow2.U5)(width),height=(0,pow2.U5)(height),{width,height}}getTexture(options,resolution,style,_textKey){"string"==typeof options&&((0,deprecation.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),options={text:options,style,resolution}),options.style instanceof TextStyle.x||(options.style=new TextStyle.x(options.style));const{texture,canvasAndContext}=this.createTextureAndCanvas(options);return this._renderer.texture.initSource(texture._source),CanvasPool.N.returnCanvasAndContext(canvasAndContext),texture}createTextureAndCanvas(options){const{text,style}=options,resolution=options.resolution??this._renderer.resolution,measured=CanvasTextMetrics.P.measureText(text||" ",style),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution),canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(width,height),{canvas}=canvasAndContext;this.renderTextToCanvas(text,style,resolution,canvasAndContext);const texture=(0,getPo2TextureFromSource.M)(canvas,width,height,resolution);if(style.trim){const trimmed=function getCanvasBoundingBox(canvas,resolution=1){const{width,height}=canvas,context=canvas.getContext("2d",{willReadFrequently:!0});if(null===context)throw new TypeError("Failed to get canvas 2D context");const data=context.getImageData(0,0,width,height).data;let left=0,top=0,right=width-1,bottom=height-1;for(;top<height&&checkRow(data,width,top);)++top;if(top===height)return Rectangle.M.EMPTY;for(;checkRow(data,width,bottom);)--bottom;for(;checkColumn(data,width,left,top,bottom);)++left;for(;checkColumn(data,width,right,top,bottom);)--right;return++right,++bottom,new Rectangle.M(left/resolution,top/resolution,(right-left)/resolution,(bottom-top)/resolution)}(canvas,resolution);texture.frame.copyFrom(trimmed),texture.updateUvs()}return{texture,canvasAndContext}}getManagedTexture(text){text._resolution=text._autoResolution?this._renderer.resolution:text.resolution;const textKey=text._getKey();if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].texture;const{texture,canvasAndContext}=this.createTextureAndCanvas(text);return this._activeTextures[textKey]={canvasAndContext,texture,usageCount:1},texture}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];if(activeTexture.usageCount--,0===activeTexture.usageCount){CanvasPool.N.returnCanvasAndContext(activeTexture.canvasAndContext),TexturePool.W.returnTexture(activeTexture.texture);const source=activeTexture.texture.source;source.resource=null,source.uploadMethodId="unknown",source.alphaMode="no-premultiply-alpha",this._activeTextures[textKey]=null}}getReferenceCount(textKey){return this._activeTextures[textKey].usageCount}renderTextToCanvas(text,style,resolution,canvasAndContext){const{canvas,context}=canvasAndContext,font=(0,fontStringFromTextStyle.Z)(style),measured=CanvasTextMetrics.P.measureText(text||" ",style),lines=measured.lines,lineHeight=measured.lineHeight,lineWidths=measured.lineWidths,maxLineWidth=measured.maxLineWidth,fontProperties=measured.fontProperties,height=canvas.height;if(context.resetTransform(),context.scale(resolution,resolution),context.textBaseline=style.textBaseline,style._stroke?.width){const strokeStyle=style._stroke;context.lineWidth=strokeStyle.width,context.miterLimit=strokeStyle.miterLimit,context.lineJoin=strokeStyle.join,context.lineCap=strokeStyle.cap}let linePositionX,linePositionY;context.font=font;const passesCount=style.dropShadow?2:1;for(let i=0;i<passesCount;++i){const isShadowPass=style.dropShadow&&0===i,dsOffsetText=isShadowPass?Math.ceil(Math.max(1,height)+2*style.padding):0,dsOffsetShadow=dsOffsetText*resolution;if(isShadowPass){context.fillStyle="black",context.strokeStyle="black";const shadowOptions=style.dropShadow,dropShadowColor=shadowOptions.color,dropShadowAlpha=shadowOptions.alpha;context.shadowColor=Color.Q.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();const dropShadowBlur=shadowOptions.blur*resolution,dropShadowDistance=shadowOptions.distance*resolution;context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(shadowOptions.angle)*dropShadowDistance,context.shadowOffsetY=Math.sin(shadowOptions.angle)*dropShadowDistance+dsOffsetShadow}else context.fillStyle=style._fill?(0,getCanvasFillStyle.r)(style._fill,context):null,style._stroke?.width&&(context.strokeStyle=(0,getCanvasFillStyle.r)(style._stroke,context)),context.shadowColor="black";let linePositionYShift=(lineHeight-fontProperties.fontSize)/2;lineHeight-fontProperties.fontSize<0&&(linePositionYShift=0);const strokeWidth=style._stroke?.width??0;for(let i2=0;i2<lines.length;i2++)linePositionX=strokeWidth/2,linePositionY=strokeWidth/2+i2*lineHeight+fontProperties.ascent+linePositionYShift,"right"===style.align?linePositionX+=maxLineWidth-lineWidths[i2]:"center"===style.align&&(linePositionX+=(maxLineWidth-lineWidths[i2])/2),style._stroke?.width&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+style.padding,linePositionY+style.padding-dsOffsetText,!0),void 0!==style._fill&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+style.padding,linePositionY+style.padding-dsOffsetText)}}_drawLetterSpacing(text,style,canvasAndContext,x,y,isStroke=!1){const{context}=canvasAndContext,letterSpacing=style.letterSpacing;let useExperimentalLetterSpacing=!1;if(CanvasTextMetrics.P.experimentalLetterSpacingSupported&&(CanvasTextMetrics.P.experimentalLetterSpacing?(context.letterSpacing=`${letterSpacing}px`,context.textLetterSpacing=`${letterSpacing}px`,useExperimentalLetterSpacing=!0):(context.letterSpacing="0px",context.textLetterSpacing="0px")),0===letterSpacing||useExperimentalLetterSpacing)return void(isStroke?context.strokeText(text,x,y):context.fillText(text,x,y));let currentPosition=x;const stringArray=CanvasTextMetrics.P.graphemeSegmenter(text);let previousWidth=context.measureText(text).width,currentWidth=0;for(let i=0;i<stringArray.length;++i){const currentChar=stringArray[i];isStroke?context.strokeText(currentChar,currentPosition,y):context.fillText(currentChar,currentPosition,y);let textStr="";for(let j=i+1;j<stringArray.length;++j)textStr+=stringArray[j];currentWidth=context.measureText(textStr).width,currentPosition+=previousWidth-currentWidth+letterSpacing,previousWidth=currentWidth}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"canvasText"},Extensions.XO.add(CanvasTextSystem),Extensions.XO.add(CanvasTextPipe)},"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{M:()=>getPo2TextureFromSource});var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");const tempBounds=new(__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs").c);function getPo2TextureFromSource(image,width,height,resolution){const bounds=tempBounds;bounds.minX=0,bounds.minY=0,bounds.maxX=image.width/resolution|0,bounds.maxY=image.height/resolution|0;const texture=_rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_0__.W.getOptimalTexture(bounds.width,bounds.height,resolution,!1);return texture.source.uploadMethodId="image",texture.source.resource=image,texture.source.alphaMode="premultiply-alpha-on-upload",texture.frame.width=width/resolution,texture.frame.height=height/resolution,texture.source.emit("update",texture.source),texture.updateUvs(),texture}}}]);