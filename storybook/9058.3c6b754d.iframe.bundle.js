"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[9058],{"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ls:()=>localUniformBit,_Q:()=>localUniformBitGroup2,mA:()=>localUniformBitGl});const localUniformBit={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{R:()=>textureBit,m:()=>textureBitGl});const textureBit={name:"texture-bit",vertex:{header:"\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",main:"\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        ",main:"\n            outColor = textureSample(uTexture, uSampler, vUV);\n        "}},textureBitGl={name:"texture-bit",vertex:{header:"\n            uniform mat3 uTextureMatrix;\n        ",main:"\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n        uniform sampler2D uTexture;\n\n         \n        ",main:"\n            outColor = texture(uTexture, vUV);\n        "}}},"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{q:()=>ensureAttributes});var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");function ensureAttributes(geometry,extractedData){for(const i in geometry.attributes){const attribute=geometry.attributes[i],attributeData=extractedData[i];attributeData?(attribute.format??(attribute.format=attributeData.format),attribute.offset??(attribute.offset=attributeData.offset),attribute.instance??(attribute.instance=attributeData.instance)):(0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}!function ensureStartAndStride(geometry){const{buffers,attributes}=geometry,tempStride={},tempStart={};for(const j in buffers){const buffer=buffers[j];tempStride[buffer.uid]=0,tempStart[buffer.uid]=0}for(const j in attributes){const attribute=attributes[j];tempStride[attribute.buffer.uid]+=(0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(attribute.format).stride}for(const j in attributes){const attribute=attributes[j];attribute.stride??(attribute.stride=tempStride[attribute.buffer.uid]),attribute.start??(attribute.start=tempStart[attribute.buffer.uid]),tempStart[attribute.buffer.uid]+=(0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(attribute.format).stride}}(geometry)}},"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{g:()=>GpuStencilModesToPixi});var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");const GpuStencilModesToPixi=[];GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.NONE]=void 0,GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.DISABLED]={stencilWriteMask:0,stencilReadMask:0},GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}},GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}},GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}},GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.K.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"replace"},stencilBack:{compare:"not-equal",passOp:"replace"}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{d:()=>BufferResource});var eventemitter3__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/node_modules/eventemitter3/index.mjs"),_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/utils/data/uid.mjs");class BufferResource extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__.A{constructor({buffer,offset,size}){super(),this.uid=(0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.L)("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=(0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.L)("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=buffer,this.offset=0|offset,this.size=size,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=(0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.L)("resource"),this.emit("change",this)}destroy(destroyBuffer=!1){this.destroyed=!0,destroyBuffer&&this.buffer.destroy(),this.emit("change",this),this.buffer=null}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{O:()=>RenderTarget});var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/utils/data/uid.mjs"),_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"),_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");const _RenderTarget=class _RenderTarget{constructor(descriptor={}){if(this.uid=(0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.L)("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,descriptor={..._RenderTarget.defaultOptions,...descriptor},this.stencil=descriptor.stencil,this.depth=descriptor.depth,this.isRoot=descriptor.isRoot,"number"==typeof descriptor.colorTextures){this._managedColorTextures=!0;for(let i=0;i<descriptor.colorTextures;i++)this.colorTextures.push(new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.v({width:descriptor.width,height:descriptor.height,resolution:descriptor.resolution,antialias:descriptor.antialias}))}else{this.colorTextures=[...descriptor.colorTextures.map(texture=>texture.source)];const colorSource=this.colorTexture.source;this.resize(colorSource.width,colorSource.height,colorSource._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(descriptor.depthStencilTexture||this.stencil)&&(descriptor.depthStencilTexture instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.g||descriptor.depthStencilTexture instanceof _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.v?this.depthStencilTexture=descriptor.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const _size=this._size;return _size[0]=this.pixelWidth,_size[1]=this.pixelHeight,_size}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(source){this.resize(source.width,source.height,source._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.v({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(width,height,resolution=this.resolution,skipColorTexture=!1){this.dirtyId++,this.colorTextures.forEach((colorTexture,i)=>{skipColorTexture&&0===i||colorTexture.source.resize(width,height,resolution)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(width,height,resolution)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(texture=>{texture.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};_RenderTarget.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let RenderTarget=_RenderTarget},"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{l:()=>RenderTargetSystem});var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"),gl_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");var SystemRunner=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"),CanvasSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"),TextureSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),getCanvasTexture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs");var RenderTarget=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs");class RenderTargetSystem{constructor(renderer){this.rootViewPort=new Rectangle.M,this.viewport=new Rectangle.M,this.onRenderTargetChange=new SystemRunner.C("onRenderTargetChange"),this.projectionMatrix=new Matrix.u,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=renderer,renderer.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target,clear,clearColor,frame}){this._renderTargetStack.length=0,this.push(target,clear,clearColor,frame),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=function isRenderingToScreen(renderTarget){const resource=renderTarget.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&resource instanceof HTMLCanvasElement&&document.body.contains(resource)}(this.rootRenderTarget),this.adaptor.prerender?.(this.rootRenderTarget)}postrender(){this.adaptor.postrender?.(this.rootRenderTarget)}bind(renderSurface,clear=!0,clearColor,frame){const renderTarget=this.getRenderTarget(renderSurface),didChange=this.renderTarget!==renderTarget;this.renderTarget=renderTarget,this.renderSurface=renderSurface;const gpuRenderTarget=this.getGpuRenderTarget(renderTarget);renderTarget.pixelWidth===gpuRenderTarget.width&&renderTarget.pixelHeight===gpuRenderTarget.height||(this.adaptor.resizeGpuRenderTarget(renderTarget),gpuRenderTarget.width=renderTarget.pixelWidth,gpuRenderTarget.height=renderTarget.pixelHeight);const source=renderTarget.colorTexture,viewport=this.viewport,pixelWidth=source.pixelWidth,pixelHeight=source.pixelHeight;if(!frame&&renderSurface instanceof Texture.g&&(frame=renderSurface.frame),frame){const resolution=source._resolution;viewport.x=frame.x*resolution+.5|0,viewport.y=frame.y*resolution+.5|0,viewport.width=frame.width*resolution+.5|0,viewport.height=frame.height*resolution+.5|0}else viewport.x=0,viewport.y=0,viewport.width=pixelWidth,viewport.height=pixelHeight;return function calculateProjection(pm,x,y,width,height,flipY){const sign=flipY?1:-1;return pm.identity(),pm.a=1/width*2,pm.d=sign*(1/height*2),pm.tx=-1-x*pm.a,pm.ty=-sign-y*pm.d,pm}(this.projectionMatrix,0,0,viewport.width/source.resolution,viewport.height/source.resolution,!renderTarget.isRoot),this.adaptor.startRenderPass(renderTarget,clear,clearColor,viewport),didChange&&this.onRenderTargetChange.emit(renderTarget),renderTarget}clear(target,clear=gl_const.u.ALL,clearColor){clear&&(target&&(target=this.getRenderTarget(target)),this.adaptor.clear(target||this.renderTarget,clear,clearColor,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(renderSurface,clear=gl_const.u.ALL,clearColor,frame){const renderTarget=this.bind(renderSurface,clear,clearColor,frame);return this._renderTargetStack.push({renderTarget,frame}),renderTarget}pop(){this._renderTargetStack.pop();const currentRenderTargetData=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(currentRenderTargetData.renderTarget,!1,null,currentRenderTargetData.frame)}getRenderTarget(renderSurface){return renderSurface.isTexture&&(renderSurface=renderSurface.source),this._renderSurfaceToRenderTargetHash.get(renderSurface)??this._initRenderTarget(renderSurface)}copyToTexture(sourceRenderSurfaceTexture,destinationTexture,originSrc,size,originDest){originSrc.x<0&&(size.width+=originSrc.x,originDest.x-=originSrc.x,originSrc.x=0),originSrc.y<0&&(size.height+=originSrc.y,originDest.y-=originSrc.y,originSrc.y=0);const{pixelWidth,pixelHeight}=sourceRenderSurfaceTexture;return size.width=Math.min(size.width,pixelWidth-originSrc.x),size.height=Math.min(size.height,pixelHeight-originSrc.y),this.adaptor.copyToTexture(sourceRenderSurfaceTexture,destinationTexture,originSrc,size,originDest)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((renderTarget,key)=>{renderTarget!==key&&renderTarget.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(renderSurface){let renderTarget=null;return CanvasSource.q.test(renderSurface)&&(renderSurface=(0,getCanvasTexture.c)(renderSurface).source),renderSurface instanceof RenderTarget.O?renderTarget=renderSurface:renderSurface instanceof TextureSource.v&&(renderTarget=new RenderTarget.O({colorTextures:[renderSurface]}),CanvasSource.q.test(renderSurface.source.resource)&&(renderTarget.isRoot=!0),renderSurface.once("destroy",()=>{renderTarget.destroy(),this._renderSurfaceToRenderTargetHash.delete(renderSurface);const gpuRenderTarget=this._gpuRenderTargetHash[renderTarget.uid];gpuRenderTarget&&(this._gpuRenderTargetHash[renderTarget.uid]=null,this.adaptor.destroyGpuRenderTarget(gpuRenderTarget))})),this._renderSurfaceToRenderTargetHash.set(renderSurface,renderTarget),renderTarget}getGpuRenderTarget(renderTarget){return this._gpuRenderTargetHash[renderTarget.uid]||(this._gpuRenderTargetHash[renderTarget.uid]=this.adaptor.initGpuRenderTarget(renderTarget))}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{W:()=>UboSystem});var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"),_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");class UboSystem{constructor(adaptor){this._syncFunctionHash=Object.create(null),this._adaptor=adaptor,this._systemCheck()}_systemCheck(){if(!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__.f)())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(uniformGroup){const uniformData=this.getUniformGroupData(uniformGroup);uniformGroup.buffer||(uniformGroup.buffer=new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.h({data:new Float32Array(uniformData.layout.size/4),usage:_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.S.UNIFORM|_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.S.COPY_DST}))}getUniformGroupData(uniformGroup){return this._syncFunctionHash[uniformGroup._signature]||this._initUniformGroup(uniformGroup)}_initUniformGroup(uniformGroup){const uniformGroupSignature=uniformGroup._signature;let uniformData=this._syncFunctionHash[uniformGroupSignature];if(!uniformData){const elements=Object.keys(uniformGroup.uniformStructures).map(i=>uniformGroup.uniformStructures[i]),layout=this._adaptor.createUboElements(elements),syncFunction=this._generateUboSync(layout.uboElements);uniformData=this._syncFunctionHash[uniformGroupSignature]={layout,syncFunction}}return this._syncFunctionHash[uniformGroupSignature]}_generateUboSync(uboElements){return this._adaptor.generateUboSync(uboElements)}syncUniformGroup(uniformGroup,data,offset){const uniformGroupData=this.getUniformGroupData(uniformGroup);uniformGroup.buffer||(uniformGroup.buffer=new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.h({data:new Float32Array(uniformGroupData.layout.size/4),usage:_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.S.UNIFORM|_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.S.COPY_DST}));let dataInt32=null;return data||(data=uniformGroup.buffer.data,dataInt32=uniformGroup.buffer.dataInt32),offset||(offset=0),uniformGroupData.syncFunction(uniformGroup.uniforms,data,dataInt32,offset),!0}updateUniformGroup(uniformGroup){if(uniformGroup.isStatic&&!uniformGroup._dirtyId)return!1;uniformGroup._dirtyId=0;const synced=this.syncUniformGroup(uniformGroup);return uniformGroup.buffer.update(),synced}destroy(){this._syncFunctionHash=null}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{E:()=>createUboSyncFunction});var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs");function createUboSyncFunction(uboElements,parserCode,arrayGenerationFunction,singleSettersMap){const funcFragments=["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "];let prev=0;for(let i=0;i<uboElements.length;i++){const uboElement=uboElements[i],name=uboElement.data.name;let parsed=!1,offset=0;for(let j=0;j<_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.$.length;j++){if(_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.$[j].test(uboElement.data)){offset=uboElement.offset/4,funcFragments.push(`name = "${name}";`,`offset += ${offset-prev};`,_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.$[j][parserCode]||_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.$[j].ubo),parsed=!0;break}}if(!parsed)if(uboElement.data.size>1)offset=uboElement.offset/4,funcFragments.push(arrayGenerationFunction(uboElement,offset-prev));else{const template=singleSettersMap[uboElement.data.type];offset=uboElement.offset/4,funcFragments.push(`\n                    v = uv.${name};\n                    offset += ${offset-prev};\n                    ${template};\n                `)}prev=offset}const fragmentSrc=funcFragments.join("\n");return new Function("uv","data","dataInt32","offset",fragmentSrc)}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function loopMatrix(col,row){return`\n        for (let i = 0; i < ${col*row}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `}__webpack_require__.d(__webpack_exports__,{_:()=>uboSyncFunctionsWGSL,g:()=>uboSyncFunctionsSTD40});const uboSyncFunctionsSTD40={f32:"\n        data[offset] = v;",i32:"\n        dataInt32[offset] = v;","vec2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];","vec3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];","vec4<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];","vec2<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];","vec3<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];","vec4<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];","mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];","mat3x3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];","mat4x4<f32>":"\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }","mat3x2<f32>":loopMatrix(3,2),"mat4x2<f32>":loopMatrix(4,2),"mat2x3<f32>":loopMatrix(2,3),"mat4x3<f32>":loopMatrix(4,3),"mat2x4<f32>":loopMatrix(2,4),"mat3x4<f32>":loopMatrix(3,4)},uboSyncFunctionsWGSL={...uboSyncFunctionsSTD40,"mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    "}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$:()=>uniformParsers});const uniformParsers=[{type:"mat3x3<f32>",test:data=>void 0!==data.value.a,ubo:"\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ",uniform:"\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        "},{type:"vec4<f32>",test:data=>"vec4<f32>"===data.type&&1===data.size&&void 0!==data.value.width,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        "},{type:"vec2<f32>",test:data=>"vec2<f32>"===data.type&&1===data.size&&void 0!==data.value.x,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        "},{type:"vec4<f32>",test:data=>"vec4<f32>"===data.type&&1===data.size&&void 0!==data.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        "},{type:"vec3<f32>",test:data=>"vec3<f32>"===data.type&&1===data.size&&void 0!==data.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        "}]},"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>State});const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},_State=class _State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(value){!!(1&this.data)!==value&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(value){!!(2&this.data)!==value&&(this.data^=2)}set cullMode(value){"none"!==value?(this.culling=!0,this.clockwiseFrontFace="front"===value):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(value){!!(4&this.data)!==value&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(value){!!(8&this.data)!==value&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(value){!!(32&this.data)!==value&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(value){!!(16&this.data)!==value&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(value){this.blend="none"!==value,this._blendMode=value,this._blendModeId=blendModeIds[value]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(value){this.offsets=!!value,this._polygonOffset=value}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const state=new _State;return state.depthTest=!1,state.blend=!0,state}};_State.default2d=_State.for2d();let State=_State},"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{f:()=>SharedRenderPipes,i:()=>SharedSystems});var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class CustomRenderPipe{constructor(renderer){this._renderer=renderer}updateRenderable(){}destroyRenderable(){}validateRenderable(){return!1}addRenderable(container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add(container)}execute(container){container.isRenderable&&container.render(this._renderer)}destroy(){this._renderer=null}}CustomRenderPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"customRender"};var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");function executeInstructions(renderGroup,renderer){const instructionSet=renderGroup.instructionSet,instructions=instructionSet.instructions;for(let i=0;i<instructionSet.instructionSize;i++){const instruction=instructions[i];renderer[instruction.renderPipeId].execute(instruction)}}const tempMatrix=new Matrix.u;class RenderGroupPipe{constructor(renderer){this._renderer=renderer}addRenderGroup(renderGroup,instructionSet){renderGroup.isCachedAsTexture?this._addRenderableCacheAsTexture(renderGroup,instructionSet):this._addRenderableDirect(renderGroup,instructionSet)}execute(renderGroup){renderGroup.isRenderable&&(renderGroup.isCachedAsTexture?this._executeCacheAsTexture(renderGroup):this._executeDirect(renderGroup))}destroy(){this._renderer=null}_addRenderableDirect(renderGroup,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),renderGroup._batchableRenderGroup&&(PoolGroup.Z.return(renderGroup._batchableRenderGroup),renderGroup._batchableRenderGroup=null),instructionSet.add(renderGroup)}_addRenderableCacheAsTexture(renderGroup,instructionSet){const batchableRenderGroup=renderGroup._batchableRenderGroup??(renderGroup._batchableRenderGroup=PoolGroup.Z.get(BatchableSprite.K));batchableRenderGroup.renderable=renderGroup.root,batchableRenderGroup.transform=renderGroup.root.relativeGroupTransform,batchableRenderGroup.texture=renderGroup.texture,batchableRenderGroup.bounds=renderGroup._textureBounds,instructionSet.add(renderGroup),this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup,instructionSet)}_executeCacheAsTexture(renderGroup){if(renderGroup.textureNeedsUpdate){renderGroup.textureNeedsUpdate=!1;const worldTransformMatrix=tempMatrix.identity().translate(-renderGroup._textureBounds.x,-renderGroup._textureBounds.y);this._renderer.renderTarget.push(renderGroup.texture,!0,null,renderGroup.texture.frame),this._renderer.globalUniforms.push({worldTransformMatrix,worldColor:4294967295}),executeInstructions(renderGroup,this._renderer.renderPipes),this._renderer.renderTarget.pop(),this._renderer.globalUniforms.pop()}renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup),renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(renderGroup){this._renderer.globalUniforms.push({worldTransformMatrix:renderGroup.inverseParentTextureTransform,worldColor:renderGroup.worldColorAlpha}),executeInstructions(renderGroup,this._renderer.renderPipes),this._renderer.globalUniforms.pop()}}RenderGroupPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"renderGroup"};var TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),Bounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");function collectAllRenderables(container,instructionSet,rendererOrPipes){const renderer=rendererOrPipes.renderPipes?rendererOrPipes:rendererOrPipes.batch.renderer;container.globalDisplayStatus<7||!container.includeInBuild||(container.sortableChildren&&container.sortChildren(),container.isSimple?function collectAllRenderablesSimple(container,instructionSet,renderer){if(container.renderPipeId){const renderable=container,{renderPipes,renderableGC}=renderer;renderPipes.blendMode.setBlendMode(renderable,container.groupBlendMode,instructionSet);renderPipes[renderable.renderPipeId].addRenderable(renderable,instructionSet),renderableGC.addRenderable(renderable,instructionSet),renderable.didViewUpdate=!1}if(!container.renderGroup){const children=container.children,length=children.length;for(let i=0;i<length;i++)collectAllRenderables(children[i],instructionSet,renderer)}}(container,instructionSet,renderer):collectAllRenderablesAdvanced(container,instructionSet,renderer,!1))}function collectAllRenderablesAdvanced(container,instructionSet,renderer,isRoot){const{renderPipes,renderableGC}=renderer;if(!isRoot&&container.renderGroup)renderPipes.renderGroup.addRenderGroup(container.renderGroup,instructionSet);else{for(let i=0;i<container.effects.length;i++){const effect=container.effects[i];renderPipes[effect.pipe].push(effect,container,instructionSet)}const renderable=container,renderPipeId=renderable.renderPipeId;if(renderPipeId){renderPipes.blendMode.setBlendMode(renderable,renderable.groupBlendMode,instructionSet);renderPipes[renderPipeId].addRenderable(renderable,instructionSet),renderableGC.addRenderable(renderable,instructionSet),renderable.didViewUpdate=!1}const children=container.children;if(children.length)for(let i=0;i<children.length;i++)collectAllRenderables(children[i],instructionSet,renderer);for(let i=container.effects.length-1;i>=0;i--){const effect=container.effects[i];renderPipes[effect.pipe].pop(effect,container,instructionSet)}}}function clearList(list,index){index||(index=0);for(let j=index;j<list.length&&list[j];j++)list[j]=null}var Container=__webpack_require__("./node_modules/pixi.js/lib/scene/container/Container.mjs"),multiplyColors=__webpack_require__("./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs");const tempContainer=new Container.mc,UPDATE_BLEND_COLOR_VISIBLE=Container.fR|Container.ig|Container.u;function updateRenderGroupTransforms(renderGroup,updateChildRenderGroups=!1){!function updateRenderGroupTransform(renderGroup){const root=renderGroup.root;let worldAlpha;if(renderGroup.renderGroupParent){const renderGroupParent=renderGroup.renderGroupParent;renderGroup.worldTransform.appendFrom(root.relativeGroupTransform,renderGroupParent.worldTransform),renderGroup.worldColor=(0,multiplyColors.j)(root.groupColor,renderGroupParent.worldColor),worldAlpha=root.groupAlpha*renderGroupParent.worldAlpha}else renderGroup.worldTransform.copyFrom(root.localTransform),renderGroup.worldColor=root.localColor,worldAlpha=root.localAlpha;worldAlpha=worldAlpha<0?0:worldAlpha>1?1:worldAlpha,renderGroup.worldAlpha=worldAlpha,renderGroup.worldColorAlpha=renderGroup.worldColor+(255*worldAlpha<<24)}(renderGroup);const childrenToUpdate=renderGroup.childrenToUpdate,updateTick=renderGroup.updateTick++;for(const j in childrenToUpdate){const renderGroupDepth=Number(j),childrenAtDepth=childrenToUpdate[j],list=childrenAtDepth.list,index=childrenAtDepth.index;for(let i=0;i<index;i++){const child=list[i];child.parentRenderGroup===renderGroup&&child.relativeRenderGroupDepth===renderGroupDepth&&updateTransformAndChildren(child,updateTick,0)}clearList(list,index),childrenAtDepth.index=0}if(updateChildRenderGroups)for(let i=0;i<renderGroup.renderGroupChildren.length;i++)updateRenderGroupTransforms(renderGroup.renderGroupChildren[i],updateChildRenderGroups)}function updateTransformAndChildren(container,updateTick,updateFlags){if(updateTick===container.updateTick)return;container.updateTick=updateTick,container.didChange=!1;const localTransform=container.localTransform;container.updateLocalTransform();const parent=container.parent;if(parent&&!parent.renderGroup?(updateFlags|=container._updateFlags,container.relativeGroupTransform.appendFrom(localTransform,parent.relativeGroupTransform),updateFlags&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(container,parent,updateFlags)):(updateFlags=container._updateFlags,container.relativeGroupTransform.copyFrom(localTransform),updateFlags&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(container,tempContainer,updateFlags)),!container.renderGroup){const children=container.children,length=children.length;for(let i=0;i<length;i++)updateTransformAndChildren(children[i],updateTick,updateFlags);const renderGroup=container.parentRenderGroup,renderable=container;renderable.renderPipeId&&!renderGroup.structureDidChange&&renderGroup.updateRenderable(renderable)}}function updateColorBlendVisibility(container,parent,updateFlags){if(updateFlags&Container.ig){container.groupColor=(0,multiplyColors.j)(container.localColor,parent.groupColor);let groupAlpha=container.localAlpha*parent.groupAlpha;groupAlpha=groupAlpha<0?0:groupAlpha>1?1:groupAlpha,container.groupAlpha=groupAlpha,container.groupColorAlpha=container.groupColor+(255*groupAlpha<<24)}updateFlags&Container.u&&(container.groupBlendMode="inherit"===container.localBlendMode?parent.groupBlendMode:container.localBlendMode),updateFlags&Container.fR&&(container.globalDisplayStatus=container.localDisplayStatus&parent.globalDisplayStatus),container._updateFlags=0}const RenderGroupSystem_tempMatrix=new Matrix.u;class RenderGroupSystem{constructor(renderer){this._renderer=renderer}render({container,transform}){const parent=container.parent,renderGroupParent=container.renderGroup.renderGroupParent;container.parent=null,container.renderGroup.renderGroupParent=null;const renderer=this._renderer;let originalLocalTransform=RenderGroupSystem_tempMatrix;transform&&(originalLocalTransform=originalLocalTransform.copyFrom(container.renderGroup.localTransform),container.renderGroup.localTransform.copyFrom(transform));const renderPipes=renderer.renderPipes;this._updateCachedRenderGroups(container.renderGroup,null),this._updateRenderGroups(container.renderGroup),renderer.globalUniforms.start({worldTransformMatrix:transform?container.renderGroup.localTransform:container.renderGroup.worldTransform,worldColor:container.renderGroup.worldColorAlpha}),executeInstructions(container.renderGroup,renderPipes),renderPipes.uniformBatch&&renderPipes.uniformBatch.renderEnd(),transform&&container.renderGroup.localTransform.copyFrom(originalLocalTransform),container.parent=parent,container.renderGroup.renderGroupParent=renderGroupParent}destroy(){this._renderer=null}_updateCachedRenderGroups(renderGroup,closestCacheAsTexture){if(renderGroup.isCachedAsTexture){if(!renderGroup.updateCacheTexture)return;closestCacheAsTexture=renderGroup}renderGroup._parentCacheAsTextureRenderGroup=closestCacheAsTexture;for(let i=renderGroup.renderGroupChildren.length-1;i>=0;i--)this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i],closestCacheAsTexture);if(renderGroup.invalidateMatrices(),renderGroup.isCachedAsTexture){if(renderGroup.textureNeedsUpdate){const bounds=renderGroup.root.getLocalBounds();bounds.ceil();const lastTexture=renderGroup.texture;renderGroup.texture&&TexturePool.W.returnTexture(renderGroup.texture);const renderer=this._renderer,resolution=renderGroup.textureOptions.resolution||renderer.view.resolution,antialias=renderGroup.textureOptions.antialias??renderer.view.antialias;renderGroup.texture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,resolution,antialias),renderGroup._textureBounds||(renderGroup._textureBounds=new Bounds.c),renderGroup._textureBounds.copyFrom(bounds),lastTexture!==renderGroup.texture&&renderGroup.renderGroupParent&&(renderGroup.renderGroupParent.structureDidChange=!0)}}else renderGroup.texture&&(TexturePool.W.returnTexture(renderGroup.texture),renderGroup.texture=null)}_updateRenderGroups(renderGroup){const renderer=this._renderer,renderPipes=renderer.renderPipes;if(renderGroup.runOnRender(),renderGroup.instructionSet.renderPipes=renderPipes,renderGroup.structureDidChange?clearList(renderGroup.childrenRenderablesToUpdate.list,0):function validateRenderables(renderGroup,renderPipes){const{list,index}=renderGroup.childrenRenderablesToUpdate;let rebuildRequired=!1;for(let i=0;i<index;i++){const container=list[i];if(rebuildRequired=renderPipes[container.renderPipeId].validateRenderable(container),rebuildRequired)break}return renderGroup.structureDidChange=rebuildRequired,rebuildRequired}(renderGroup,renderPipes),updateRenderGroupTransforms(renderGroup),renderGroup.structureDidChange?(renderGroup.structureDidChange=!1,function buildInstructions(renderGroup,rendererOrPipes){const root=renderGroup.root,instructionSet=renderGroup.instructionSet;instructionSet.reset();const renderer=rendererOrPipes.renderPipes?rendererOrPipes:rendererOrPipes.batch.renderer,renderPipes=renderer.renderPipes;renderPipes.batch.buildStart(instructionSet),renderPipes.blendMode.buildStart(),renderPipes.colorMask.buildStart(),root.sortableChildren&&root.sortChildren(),collectAllRenderablesAdvanced(root,instructionSet,renderer,!0),renderPipes.batch.buildEnd(instructionSet),renderPipes.blendMode.buildEnd(instructionSet)}(renderGroup,renderer)):this._updateRenderables(renderGroup),renderGroup.childrenRenderablesToUpdate.index=0,renderer.renderPipes.batch.upload(renderGroup.instructionSet),!renderGroup.isCachedAsTexture||renderGroup.textureNeedsUpdate)for(let i=0;i<renderGroup.renderGroupChildren.length;i++)this._updateRenderGroups(renderGroup.renderGroupChildren[i])}_updateRenderables(renderGroup){const{list,index}=renderGroup.childrenRenderablesToUpdate;for(let i=0;i<index;i++){const container=list[i];container.didViewUpdate&&renderGroup.updateRenderable(container)}clearList(list,index)}}RenderGroupSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"renderGroup"};class SpritePipe{constructor(renderer){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(sprite,instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite,instructionSet)}updateRenderable(sprite){const gpuSprite=this._gpuSpriteHash[sprite.uid];sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite._batcher.updateElement(gpuSprite)}validateRenderable(sprite){const texture=sprite._texture,gpuSprite=this._getGpuSprite(sprite);return gpuSprite.texture._source!==texture._source&&!gpuSprite._batcher.checkAndUpdateTexture(gpuSprite,texture)}destroyRenderable(sprite){const batchableSprite=this._gpuSpriteHash[sprite.uid];PoolGroup.Z.return(batchableSprite),this._gpuSpriteHash[sprite.uid]=null,sprite.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(sprite,batchableSprite){batchableSprite.bounds=sprite.visualBounds,batchableSprite.texture=sprite._texture}_getGpuSprite(sprite){return this._gpuSpriteHash[sprite.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const batchableSprite=PoolGroup.Z.get(BatchableSprite.K);return batchableSprite.renderable=sprite,batchableSprite.transform=sprite.groupTransform,batchableSprite.texture=sprite._texture,batchableSprite.bounds=sprite.visualBounds,batchableSprite.roundPixels=this._renderer._roundPixels|sprite._roundPixels,this._gpuSpriteHash[sprite.uid]=batchableSprite,sprite.on("destroyed",this._destroyRenderableBound),batchableSprite}destroy(){for(const i in this._gpuSpriteHash)PoolGroup.Z.return(this._gpuSpriteHash[i]);this._gpuSpriteHash=null,this._renderer=null}}SpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"sprite"};var globalHooks=__webpack_require__("./node_modules/pixi.js/lib/utils/global/globalHooks.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),DefaultBatcher=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs");const _BatcherPipe=class _BatcherPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this._batchersByInstructionSet=Object.create(null),this._activeBatches=Object.create(null),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init?.(this)}static getBatcher(name){return new this._availableBatchers[name]}buildStart(instructionSet){let batchers=this._batchersByInstructionSet[instructionSet.uid];batchers||(batchers=this._batchersByInstructionSet[instructionSet.uid]=Object.create(null),batchers.default||(batchers.default=new DefaultBatcher.J)),this._activeBatches=batchers,this._activeBatch=this._activeBatches.default;for(const i in this._activeBatches)this._activeBatches[i].begin()}addToBatch(batchableObject,instructionSet){if(this._activeBatch.name!==batchableObject.batcherName){this._activeBatch.break(instructionSet);let batch=this._activeBatches[batchableObject.batcherName];batch||(batch=this._activeBatches[batchableObject.batcherName]=_BatcherPipe.getBatcher(batchableObject.batcherName),batch.begin()),this._activeBatch=batch}this._activeBatch.add(batchableObject)}break(instructionSet){this._activeBatch.break(instructionSet)}buildEnd(instructionSet){this._activeBatch.break(instructionSet);const batches=this._activeBatches;for(const i in batches){const batch=batches[i],geometry=batch.geometry;geometry.indexBuffer.setDataWithSize(batch.indexBuffer,batch.indexSize,!0),geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View,batch.attributeSize,!1)}}upload(instructionSet){const batchers=this._batchersByInstructionSet[instructionSet.uid];for(const i in batchers){const batcher=batchers[i],geometry=batcher.geometry;batcher.dirty&&(batcher.dirty=!1,geometry.buffers[0].update(4*batcher.attributeSize))}}execute(batch){if("startBatch"===batch.action){const batcher=batch.batcher,geometry=batcher.geometry,shader=batcher.shader;this._adaptor.start(this,geometry,shader)}this._adaptor.execute(this,batch)}destroy(){this.state=null,this.renderer=null,this._adaptor=null;for(const i in this._activeBatches)this._activeBatches[i].destroy();this._activeBatches=null}};_BatcherPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"batch"},_BatcherPipe._availableBatchers=Object.create(null);let BatcherPipe=_BatcherPipe;Extensions.XO.handleByMap(Extensions.Ag.Batcher,BatcherPipe._availableBatchers),Extensions.XO.add(DefaultBatcher.J);var FilterEffect=__webpack_require__("./node_modules/pixi.js/lib/filters/FilterEffect.mjs"),GlProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),GpuProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),TextureMatrix=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");const _Filter=class _Filter extends Shader.M{constructor(options){super(options={..._Filter.defaultOptions,...options}),this.enabled=!0,this._state=State.U.for2d(),this.blendMode=options.blendMode,this.padding=options.padding,"boolean"==typeof options.antialias?this.antialias=options.antialias?"on":"off":this.antialias=options.antialias,this.resolution=options.resolution,this.blendRequired=options.blendRequired,this.clipToViewport=options.clipToViewport,this.addResource("uTexture",0,1)}apply(filterManager,input,output,clearMode){filterManager.applyFilter(this,input,output,clearMode)}get blendMode(){return this._state.blendMode}set blendMode(value){this._state.blendMode=value}static from(options){const{gpu,gl,...rest}=options;let gpuProgram,glProgram;return gpu&&(gpuProgram=GpuProgram.B.from(gpu)),gl&&(glProgram=GlProgram.M.from(gl)),new _Filter({gpuProgram,glProgram,...rest})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Filter=_Filter;var source="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";class MaskFilter extends Filter{constructor(options){const{sprite,...rest}=options,textureMatrix=new TextureMatrix.N(sprite.texture),filterUniforms=new UniformGroup.k({uFilterMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uMaskClamp:{value:textureMatrix.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:options.inverse?1:0,type:"f32"}});super({...rest,gpuProgram:GpuProgram.B.from({vertex:{source,entryPoint:"mainVertex"},fragment:{source,entryPoint:"mainFragment"}}),glProgram:GlProgram.M.from({vertex:"in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n",fragment:"in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n",name:"mask-filter"}),resources:{filterUniforms,uMaskTexture:sprite.texture.source}}),this.sprite=sprite,this._textureMatrix=textureMatrix}set inverse(value){this.resources.filterUniforms.uniforms.uInverse=value?1:0}get inverse(){return 1===this.resources.filterUniforms.uniforms.uInverse}apply(filterManager,input,output,clearMode){this._textureMatrix.texture=this.sprite.texture,filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,filterManager.applyFilter(this,input,output,clearMode)}}var getGlobalBounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"),Sprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs");const tempBounds=new Bounds.c;class AlphaMaskEffect extends FilterEffect.a{constructor(){super(),this.filters=[new MaskFilter({sprite:new Sprite.k(Texture.g.EMPTY),inverse:!1,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(value){this.filters[0].sprite=value}get inverse(){return this.filters[0].inverse}set inverse(value){this.filters[0].inverse=value}}class AlphaMaskPipe{constructor(renderer){this._activeMaskStage=[],this._renderer=renderer}push(mask,maskedContainer,instructionSet){const renderer=this._renderer;if(renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask,inverse:maskedContainer._maskOptions.inverse,canBundle:!1,maskedContainer}),mask.inverse=maskedContainer._maskOptions.inverse,mask.renderMaskToTexture){const maskContainer=mask.mask;maskContainer.includeInBuild=!0,collectAllRenderables(maskContainer,instructionSet,renderer),maskContainer.includeInBuild=!1}renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask,maskedContainer,inverse:maskedContainer._maskOptions.inverse,canBundle:!1})}pop(mask,_maskedContainer,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask,inverse:_maskedContainer._maskOptions.inverse,canBundle:!1})}execute(instruction){const renderer=this._renderer,renderMask=instruction.mask.renderMaskToTexture;if("pushMaskBegin"===instruction.action){const filterEffect=PoolGroup.Z.get(AlphaMaskEffect);if(filterEffect.inverse=instruction.inverse,renderMask){instruction.mask.mask.measurable=!0;const bounds=(0,getGlobalBounds.fB)(instruction.mask.mask,!0,tempBounds);instruction.mask.mask.measurable=!1,bounds.ceil();const colorTextureSource=renderer.renderTarget.renderTarget.colorTexture.source,filterTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,colorTextureSource._resolution,colorTextureSource.antialias);renderer.renderTarget.push(filterTexture,!0),renderer.globalUniforms.push({offset:bounds,worldColor:4294967295});const sprite=filterEffect.sprite;sprite.texture=filterTexture,sprite.worldTransform.tx=bounds.minX,sprite.worldTransform.ty=bounds.minY,this._activeMaskStage.push({filterEffect,maskedContainer:instruction.maskedContainer,filterTexture})}else filterEffect.sprite=instruction.mask.mask,this._activeMaskStage.push({filterEffect,maskedContainer:instruction.maskedContainer})}else if("pushMaskEnd"===instruction.action){const maskData=this._activeMaskStage[this._activeMaskStage.length-1];renderMask&&(renderer.type===types.W.WEBGL&&renderer.renderTarget.finishRenderPass(),renderer.renderTarget.pop(),renderer.globalUniforms.pop()),renderer.filter.push({renderPipeId:"filter",action:"pushFilter",container:maskData.maskedContainer,filterEffect:maskData.filterEffect,canBundle:!1})}else if("popMaskEnd"===instruction.action){renderer.filter.pop();const maskData=this._activeMaskStage.pop();renderMask&&TexturePool.W.returnTexture(maskData.filterTexture),PoolGroup.Z.return(maskData.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(renderer){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=renderer}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(mask,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const colorStack=this._colorStack;colorStack[this._colorStackIndex]=colorStack[this._colorStackIndex-1]&mask.mask;const currentColor=this._colorStack[this._colorStackIndex];currentColor!==this._currentColor&&(this._currentColor=currentColor,instructionSet.add({renderPipeId:"colorMask",colorMask:currentColor,canBundle:!1})),this._colorStackIndex++}pop(_mask,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const colorStack=this._colorStack;this._colorStackIndex--;const currentColor=colorStack[this._colorStackIndex-1];currentColor!==this._currentColor&&(this._currentColor=currentColor,instructionSet.add({renderPipeId:"colorMask",colorMask:currentColor,canBundle:!1}))}execute(instruction){this._renderer.colorMask.setMask(instruction.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"colorMask"};var gl_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"),state_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");class StencilMaskPipe{constructor(renderer){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=renderer}push(mask,_container,instructionSet){var _a;const effect=mask,renderer=this._renderer;renderer.renderPipes.batch.break(instructionSet),renderer.renderPipes.blendMode.setBlendMode(effect.mask,"none",instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask,inverse:_container._maskOptions.inverse,canBundle:!1});const maskContainer=effect.mask;maskContainer.includeInBuild=!0,this._maskHash.has(effect)||this._maskHash.set(effect,{instructionsStart:0,instructionsLength:0});const maskData=this._maskHash.get(effect);maskData.instructionsStart=instructionSet.instructionSize,collectAllRenderables(maskContainer,instructionSet,renderer),maskContainer.includeInBuild=!1,renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask,inverse:_container._maskOptions.inverse,canBundle:!1});const instructionsLength=instructionSet.instructionSize-maskData.instructionsStart-1;maskData.instructionsLength=instructionsLength;const renderTargetUid=renderer.renderTarget.renderTarget.uid;(_a=this._maskStackHash)[renderTargetUid]??(_a[renderTargetUid]=0)}pop(mask,_container,instructionSet){const effect=mask,renderer=this._renderer;renderer.renderPipes.batch.break(instructionSet),renderer.renderPipes.blendMode.setBlendMode(effect.mask,"none",instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:_container._maskOptions.inverse,canBundle:!1});const maskData=this._maskHash.get(mask);for(let i=0;i<maskData.instructionsLength;i++)instructionSet.instructions[instructionSet.instructionSize++]=instructionSet.instructions[maskData.instructionsStart++];instructionSet.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(instruction){var _a;const renderer=this._renderer,renderTargetUid=renderer.renderTarget.renderTarget.uid;let maskStackIndex=(_a=this._maskStackHash)[renderTargetUid]??(_a[renderTargetUid]=0);"pushMaskBegin"===instruction.action?(renderer.renderTarget.ensureDepthStencil(),renderer.stencil.setStencilMode(state_const.K.RENDERING_MASK_ADD,maskStackIndex),maskStackIndex++,renderer.colorMask.setMask(0)):"pushMaskEnd"===instruction.action?(instruction.inverse?renderer.stencil.setStencilMode(state_const.K.INVERSE_MASK_ACTIVE,maskStackIndex):renderer.stencil.setStencilMode(state_const.K.MASK_ACTIVE,maskStackIndex),renderer.colorMask.setMask(15)):"popMaskBegin"===instruction.action?(renderer.colorMask.setMask(0),0!==maskStackIndex?renderer.stencil.setStencilMode(state_const.K.RENDERING_MASK_REMOVE,maskStackIndex):(renderer.renderTarget.clear(null,gl_const.u.STENCIL),renderer.stencil.setStencilMode(state_const.K.DISABLED,maskStackIndex)),maskStackIndex--):"popMaskEnd"===instruction.action&&(instruction.inverse?renderer.stencil.setStencilMode(state_const.K.INVERSE_MASK_ACTIVE,maskStackIndex):renderer.stencil.setStencilMode(state_const.K.MASK_ACTIVE,maskStackIndex),renderer.colorMask.setMask(15)),this._maskStackHash[renderTargetUid]=maskStackIndex}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"stencilMask"};var Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs");const _BackgroundSystem=class _BackgroundSystem{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color.Q(0),this.color=this._backgroundColor,this.alpha=1}init(options){options={..._BackgroundSystem.defaultOptions,...options},this.clearBeforeRender=options.clearBeforeRender,this.color=options.background||options.backgroundColor||this._backgroundColor,this.alpha=options.backgroundAlpha,this._backgroundColor.setAlpha(options.backgroundAlpha)}get color(){return this._backgroundColor}set color(value){this._backgroundColor.setValue(value)}get alpha(){return this._backgroundColor.alpha}set alpha(value){this._backgroundColor.setAlpha(value)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};_BackgroundSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"background",priority:0},_BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let BackgroundSystem=_BackgroundSystem;var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");const BLEND_MODE_FILTERS={};Extensions.XO.handle(Extensions.Ag.BlendMode,value=>{if(!value.name)throw new Error("BlendMode extension must have a name property");BLEND_MODE_FILTERS[value.name]=value.ref},value=>{delete BLEND_MODE_FILTERS[value.name]});class BlendModePipe{constructor(renderer){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=renderer}setBlendMode(renderable,blendMode,instructionSet){this._activeBlendMode!==blendMode?(this._activeBlendMode=blendMode,this._isAdvanced&&this._endAdvancedBlendMode(instructionSet),this._isAdvanced=!!BLEND_MODE_FILTERS[blendMode],this._isAdvanced&&(this._beginAdvancedBlendMode(instructionSet),this._renderableList.push(renderable))):this._isAdvanced&&this._renderableList.push(renderable)}_beginAdvancedBlendMode(instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const blendMode=this._activeBlendMode;if(!BLEND_MODE_FILTERS[blendMode])return void(0,warn.R)(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);let filterEffect=this._filterHash[blendMode];filterEffect||(filterEffect=this._filterHash[blendMode]=new FilterEffect.a,filterEffect.filters=[new BLEND_MODE_FILTERS[blendMode]]);const instruction={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect,canBundle:!1};this._renderableList=instruction.renderables,instructionSet.add(instruction)}_endAdvancedBlendMode(instructionSet){this._renderableList=null,this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(instructionSet){this._isAdvanced&&this._endAdvancedBlendMode(instructionSet)}destroy(){this._renderer=null,this._renderableList=null;for(const i in this._filterHash)this._filterHash[i].destroy();this._filterHash=null}}BlendModePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"blendMode"};const imageTypes={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},_ExtractSystem=class _ExtractSystem{constructor(renderer){this._renderer=renderer}_normalizeOptions(options,defaults={}){return options instanceof Container.mc||options instanceof Texture.g?{target:options,...defaults}:{...defaults,...options}}async image(options){const image=new Image;return image.src=await this.base64(options),image}async base64(options){options=this._normalizeOptions(options,_ExtractSystem.defaultImageOptions);const{format,quality}=options,canvas=this.canvas(options);if(void 0!==canvas.toBlob)return new Promise((resolve,reject)=>{canvas.toBlob(blob=>{if(!blob)return void reject(new Error("ICanvas.toBlob failed!"));const reader=new FileReader;reader.onload=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)},imageTypes[format],quality)});if(void 0!==canvas.toDataURL)return canvas.toDataURL(imageTypes[format],quality);if(void 0!==canvas.convertToBlob){const blob=await canvas.convertToBlob({type:imageTypes[format],quality});return new Promise((resolve,reject)=>{const reader=new FileReader;reader.onload=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(options){const target=(options=this._normalizeOptions(options)).target,renderer=this._renderer;if(target instanceof Texture.g)return renderer.texture.generateCanvas(target);const texture=renderer.textureGenerator.generateTexture(options),canvas=renderer.texture.generateCanvas(texture);return texture.destroy(),canvas}pixels(options){const target=(options=this._normalizeOptions(options)).target,renderer=this._renderer,texture=target instanceof Texture.g?target:renderer.textureGenerator.generateTexture(options),pixelInfo=renderer.texture.getPixels(texture);return target instanceof Container.mc&&texture.destroy(),pixelInfo}texture(options){return(options=this._normalizeOptions(options)).target instanceof Texture.g?options.target:this._renderer.textureGenerator.generateTexture(options)}download(options){options=this._normalizeOptions(options);const canvas=this.canvas(options),link=document.createElement("a");link.download=options.filename??"image.png",link.href=canvas.toDataURL("image/png"),document.body.appendChild(link),link.click(),document.body.removeChild(link)}log(options){const width=options.width??200;options=this._normalizeOptions(options);const canvas=this.canvas(options),base64=canvas.toDataURL();console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);const style=["font-size: 1px;",`padding: ${width}px 300px;`,`background: url(${base64}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",style)}destroy(){this._renderer=null}};_ExtractSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"extract"},_ExtractSystem.defaultImageOptions={format:"png",quality:1};let ExtractSystem=_ExtractSystem;var Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"),getLocalBounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"),TextureSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");class RenderTexture extends Texture.g{static create(options){return new RenderTexture({source:new TextureSource.v(options)})}resize(width,height,resolution){return this.source.resize(width,height,resolution),this}}const tempRect=new Rectangle.M,GenerateTextureSystem_tempBounds=new Bounds.c,noColor=[0,0,0,0];class GenerateTextureSystem{constructor(renderer){this._renderer=renderer}generateTexture(options){options instanceof Container.mc&&(options={target:options,frame:void 0,textureSourceOptions:{},resolution:void 0});const resolution=options.resolution||this._renderer.resolution,antialias=options.antialias||this._renderer.view.antialias,container=options.target;let clearColor=options.clearColor;if(clearColor){clearColor=Array.isArray(clearColor)&&4===clearColor.length?clearColor:Color.Q.shared.setValue(clearColor).toArray()}else clearColor=noColor;const region=options.frame?.copyTo(tempRect)||(0,getLocalBounds.n)(container,GenerateTextureSystem_tempBounds).rectangle;region.width=0|Math.max(region.width,1/resolution),region.height=0|Math.max(region.height,1/resolution);const target=RenderTexture.create({...options.textureSourceOptions,width:region.width,height:region.height,resolution,antialias}),transform=Matrix.u.shared.translate(-region.x,-region.y);return this._renderer.render({container,transform,target,clearColor}),target.source.updateMipmaps(),target}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"textureGenerator"};var Point=__webpack_require__("./node_modules/pixi.js/lib/maths/point/Point.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");class GlobalUniformSystem{constructor(renderer){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=renderer}reset(){this._stackIndex=0;for(let i=0;i<this._activeUniforms.length;i++)this._uniformsPool.push(this._activeUniforms[i]);for(let i=0;i<this._activeBindGroups.length;i++)this._bindGroupPool.push(this._activeBindGroups[i]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(options){this.reset(),this.push(options)}bind({size,projectionMatrix,worldTransformMatrix,worldColor,offset}){const renderTarget=this._renderer.renderTarget.renderTarget,currentGlobalUniformData=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{projectionData:renderTarget,worldTransformMatrix:new Matrix.u,worldColor:4294967295,offset:new Point.b},globalUniformData={projectionMatrix:projectionMatrix||this._renderer.renderTarget.projectionMatrix,resolution:size||renderTarget.size,worldTransformMatrix:worldTransformMatrix||currentGlobalUniformData.worldTransformMatrix,worldColor:worldColor||currentGlobalUniformData.worldColor,offset:offset||currentGlobalUniformData.offset,bindGroup:null},uniformGroup=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(uniformGroup);const uniforms=uniformGroup.uniforms;let bindGroup;uniforms.uProjectionMatrix=globalUniformData.projectionMatrix,uniforms.uResolution=globalUniformData.resolution,uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix),uniforms.uWorldTransformMatrix.tx-=globalUniformData.offset.x,uniforms.uWorldTransformMatrix.ty-=globalUniformData.offset.y,(0,colorToUniform.V)(globalUniformData.worldColor,uniforms.uWorldColorAlpha,0),uniformGroup.update(),this._renderer.renderPipes.uniformBatch?bindGroup=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup,!1):(bindGroup=this._bindGroupPool.pop()||new BindGroup.T,this._activeBindGroups.push(bindGroup),bindGroup.setResource(uniformGroup,0)),globalUniformData.bindGroup=bindGroup,this._currentGlobalUniformData=globalUniformData}push(options){this.bind(options),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===types.W.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup.k({uProjectionMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"globalUniforms"};var Ticker=__webpack_require__("./node_modules/pixi.js/lib/ticker/Ticker.mjs");let uid=1;class SchedulerSystem{constructor(){this._tasks=[],this._offset=0}init(){Ticker.R.system.add(this._update,this)}repeat(func,duration,useOffset=!0){const id=uid++;let offset=0;return useOffset&&(this._offset+=1e3,offset=this._offset),this._tasks.push({func,duration,start:performance.now(),offset,last:performance.now(),repeat:!0,id}),id}cancel(id){for(let i=0;i<this._tasks.length;i++)if(this._tasks[i].id===id)return void this._tasks.splice(i,1)}_update(){const now=performance.now();for(let i=0;i<this._tasks.length;i++){const task=this._tasks[i];if(now-task.offset-task.last>=task.duration){const elapsed=now-task.start;task.func(elapsed),task.last=now}}}destroy(){Ticker.R.system.remove(this._update,this),this._tasks.length=0}}SchedulerSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"scheduler",priority:0};var adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs"),utils_const=__webpack_require__("./node_modules/pixi.js/lib/utils/const.mjs");let saidHello=!1;class HelloSystem{constructor(renderer){this._renderer=renderer}init(options){if(options.hello){let name=this._renderer.name;this._renderer.type===types.W.WEBGL&&(name+=` ${this._renderer.context.webGLVersion}`),function sayHello(type){if(!saidHello){if(adapter.e.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const args=[`%c  %c  %c  %c  %c PixiJS %c v${utils_const.xv} (${type}) http://www.pixijs.com/\n\n`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...args)}else globalThis.console&&globalThis.console.log(`PixiJS ${utils_const.xv} - ${type} - http://www.pixijs.com/`);saidHello=!0}}(name)}}}function cleanHash(hash){let clean=!1;for(const i in hash)if(null==hash[i]){clean=!0;break}if(!clean)return hash;const cleanHash2=Object.create(null);for(const i in hash){const value=hash[i];value&&(cleanHash2[i]=value)}return cleanHash2}function cleanArray(arr){let offset=0;for(let i=0;i<arr.length;i++)null==arr[i]?offset++:arr[i-offset]=arr[i];return arr.length=arr.length-offset,arr}HelloSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"hello",priority:-2},HelloSystem.defaultOptions={hello:!1};const _RenderableGCSystem=class _RenderableGCSystem{constructor(renderer){this._managedRenderables=[],this._managedHashes=[],this._managedArrays=[],this._renderer=renderer}init(options){options={..._RenderableGCSystem.defaultOptions,...options},this.maxUnusedTime=options.renderableGCMaxUnusedTime,this._frequency=options.renderableGCFrequency,this.enabled=options.renderableGCActive}get enabled(){return!!this._handler}set enabled(value){this.enabled!==value&&(value?(this._handler=this._renderer.scheduler.repeat(()=>this.run(),this._frequency,!1),this._hashHandler=this._renderer.scheduler.repeat(()=>{for(const hash of this._managedHashes)hash.context[hash.hash]=cleanHash(hash.context[hash.hash])},this._frequency),this._arrayHandler=this._renderer.scheduler.repeat(()=>{for(const array of this._managedArrays)cleanArray(array.context[array.hash])},this._frequency)):(this._renderer.scheduler.cancel(this._handler),this._renderer.scheduler.cancel(this._hashHandler),this._renderer.scheduler.cancel(this._arrayHandler)))}addManagedHash(context,hash){this._managedHashes.push({context,hash})}addManagedArray(context,hash){this._managedArrays.push({context,hash})}prerender(){this._now=performance.now()}addRenderable(renderable,instructionSet){this.enabled&&(renderable._lastUsed=this._now,-1===renderable._lastInstructionTick&&(this._managedRenderables.push(renderable),renderable.once("destroyed",this._removeRenderable,this)),renderable._lastInstructionTick=instructionSet.tick)}run(){const now=performance.now(),managedRenderables=this._managedRenderables,renderPipes=this._renderer.renderPipes;let offset=0;for(let i=0;i<managedRenderables.length;i++){const renderable=managedRenderables[i];if(null===renderable){offset++;continue}const renderGroup=renderable.renderGroup??renderable.parentRenderGroup,currentIndex=renderGroup?.instructionSet?.tick??-1;if(renderable._lastInstructionTick!==currentIndex&&now-renderable._lastUsed>this.maxUnusedTime){if(!renderable.destroyed){renderPipes[renderable.renderPipeId].destroyRenderable(renderable)}renderable._lastInstructionTick=-1,offset++,renderable.off("destroyed",this._removeRenderable,this)}else managedRenderables[i-offset]=renderable}managedRenderables.length=managedRenderables.length-offset}destroy(){this.enabled=!1,this._renderer=null,this._managedRenderables.length=0,this._managedHashes.length=0,this._managedArrays.length=0}_removeRenderable(renderable){const index=this._managedRenderables.indexOf(renderable);index>=0&&(renderable.off("destroyed",this._removeRenderable,this),this._managedRenderables[index]=null)}};_RenderableGCSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"renderableGC",priority:0},_RenderableGCSystem.defaultOptions={renderableGCActive:!0,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let RenderableGCSystem=_RenderableGCSystem;const _TextureGCSystem=class _TextureGCSystem{constructor(renderer){this._renderer=renderer,this.count=0,this.checkCount=0}init(options){options={..._TextureGCSystem.defaultOptions,...options},this.checkCountMax=options.textureGCCheckCountMax,this.maxIdle=options.textureGCAMaxIdle??options.textureGCMaxIdle,this.active=options.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const managedTextures=this._renderer.texture.managedTextures;for(let i=0;i<managedTextures.length;i++){const texture=managedTextures[i];texture.autoGarbageCollect&&texture.resource&&texture._touched>-1&&this.count-texture._touched>this.maxIdle&&(texture._touched=-1,texture.unload())}}destroy(){this._renderer=null}};_TextureGCSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"textureGC"},_TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:null,textureGCMaxIdle:3600,textureGCCheckCountMax:600};let TextureGCSystem=_TextureGCSystem;var deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),RenderTarget=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"),getCanvasTexture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs");const _ViewSystem=class _ViewSystem{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(value){this.texture.source.autoDensity=value}get resolution(){return this.texture.source._resolution}set resolution(value){this.texture.source.resize(this.texture.source.width,this.texture.source.height,value)}init(options){(options={..._ViewSystem.defaultOptions,...options}).view&&((0,deprecation.t6)(deprecation.lj,"ViewSystem.view has been renamed to ViewSystem.canvas"),options.canvas=options.view),this.screen=new Rectangle.M(0,0,options.width,options.height),this.canvas=options.canvas||adapter.e.get().createCanvas(),this.antialias=!!options.antialias,this.texture=(0,getCanvasTexture.c)(this.canvas,options),this.renderTarget=new RenderTarget.O({colorTextures:[this.texture],depth:!!options.depth,isRoot:!0}),this.texture.source.transparent=options.backgroundAlpha<1,this.resolution=options.resolution}resize(desiredScreenWidth,desiredScreenHeight,resolution){this.texture.source.resize(desiredScreenWidth,desiredScreenHeight,resolution),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(options=!1){("boolean"==typeof options?options:!!options?.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};_ViewSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"view",priority:0},_ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};const SharedSystems=[BackgroundSystem,GlobalUniformSystem,HelloSystem,_ViewSystem,RenderGroupSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem,globalHooks.d,RenderableGCSystem,SchedulerSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe,CustomRenderPipe]},"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c:()=>getCanvasTexture});var _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"),_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");const canvasCache=new Map;function getCanvasTexture(canvas,options){if(!canvasCache.has(canvas)){const texture=new _Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.g({source:new _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_0__.q({resource:canvas,...options})}),onDestroy=()=>{canvasCache.get(canvas)===texture&&canvasCache.delete(canvas)};texture.once("destroy",onDestroy),texture.source.once("destroy",onDestroy),canvasCache.set(canvas,texture)}return canvasCache.get(canvas)}},"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function color32BitToUniform(abgr,out,offset){const alpha=(abgr>>24&255)/255;out[offset++]=(255&abgr)/255*alpha,out[offset++]=(abgr>>8&255)/255*alpha,out[offset++]=(abgr>>16&255)/255*alpha,out[offset++]=alpha}__webpack_require__.d(__webpack_exports__,{V:()=>color32BitToUniform})},"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{K:()=>BatchableSprite});class BatchableSprite{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}}}}]);