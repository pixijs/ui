"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[2857],{"./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{WebGPURenderer:()=>WebGPURenderer});var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),maxRecommendedTextures=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"),getTextureBatchBindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),colorBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"),generateTextureBatchBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"),localUniformBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");class GpuGraphicsAdaptor{init(){const localUniforms=new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),gpuProgram=(0,compileHighShaderToProgram.v)({name:"graphics",bits:[colorBit.F,(0,generateTextureBatchBit._)((0,maxRecommendedTextures.a)()),localUniformBit._Q,roundPixelsBit.b]});this.shader=new Shader.M({gpuProgram,resources:{localUniforms}})}execute(graphicsPipe,renderable){const context=renderable.context,shader=context.customShader||this.shader,renderer=graphicsPipe.renderer,contextSystem=renderer.graphicsContext,{batcher,instructions}=contextSystem.getContextRenderData(context),encoder=renderer.encoder;encoder.setGeometry(batcher.geometry,shader.gpuProgram);const globalUniformsBindGroup=renderer.globalUniforms.bindGroup;encoder.setBindGroup(0,globalUniformsBindGroup,shader.gpuProgram);const localBindGroup=renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms,!0);encoder.setBindGroup(2,localBindGroup,shader.gpuProgram);const batches=instructions.instructions;let topology=null;for(let i=0;i<instructions.instructionSize;i++){const batch=batches[i];if(batch.topology!==topology&&(topology=batch.topology,encoder.setPipelineFromGeometryProgramAndState(batcher.geometry,shader.gpuProgram,graphicsPipe.state,batch.topology)),shader.groups[1]=batch.bindGroup,!batch.gpuBindGroup){const textureBatch=batch.textures;batch.bindGroup=(0,getTextureBatchBindGroup.w)(textureBatch.textures,textureBatch.count),batch.gpuBindGroup=renderer.bindGroup.getBindGroup(batch.bindGroup,shader.gpuProgram,1)}encoder.setBindGroup(1,batch.bindGroup,shader.gpuProgram),encoder.renderPassEncoder.drawIndexed(batch.size,1,batch.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}GpuGraphicsAdaptor.extension={type:[Extensions.Ag.WebGPUPipesAdaptor],name:"graphics"};var textureBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");class GpuMeshAdapter{init(){const gpuProgram=(0,compileHighShaderToProgram.v)({name:"mesh",bits:[localUniformBit.Ls,textureBit.R,roundPixelsBit.b]});this._shader=new Shader.M({gpuProgram,resources:{uTexture:Texture.g.EMPTY._source,uSampler:Texture.g.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new Matrix.u}}}})}execute(meshPipe,mesh){const renderer=meshPipe.renderer;let shader=mesh._shader;if(shader){if(!shader.gpuProgram)return void(0,warn.R)("Mesh shader has no gpuProgram",mesh.shader)}else shader=this._shader,shader.groups[2]=renderer.texture.getTextureBindGroup(mesh.texture);const gpuProgram=shader.gpuProgram;if(gpuProgram.autoAssignGlobalUniforms&&(shader.groups[0]=renderer.globalUniforms.bindGroup),gpuProgram.autoAssignLocalUniforms){const localUniforms=meshPipe.localUniforms;shader.groups[1]=renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms,!0)}renderer.encoder.draw({geometry:mesh._geometry,shader,state:mesh.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GpuMeshAdapter.extension={type:[Extensions.Ag.WebGPUPipesAdaptor],name:"mesh"};var State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");const tempState=State.U.for2d();class GpuBatchAdaptor{start(batchPipe,geometry,shader){const renderer=batchPipe.renderer,encoder=renderer.encoder,program=shader.gpuProgram;this._shader=shader,this._geometry=geometry,encoder.setGeometry(geometry,program),tempState.blendMode="normal",renderer.pipeline.getPipeline(geometry,program,tempState);const globalUniformsBindGroup=renderer.globalUniforms.bindGroup;encoder.resetBindGroup(1),encoder.setBindGroup(0,globalUniformsBindGroup,program)}execute(batchPipe,batch){const program=this._shader.gpuProgram,renderer=batchPipe.renderer,encoder=renderer.encoder;if(!batch.bindGroup){const textureBatch=batch.textures;batch.bindGroup=(0,getTextureBatchBindGroup.w)(textureBatch.textures,textureBatch.count)}tempState.blendMode=batch.blendMode;const gpuBindGroup=renderer.bindGroup.getBindGroup(batch.bindGroup,program,1),pipeline=renderer.pipeline.getPipeline(this._geometry,program,tempState,batch.topology);batch.bindGroup._touch(renderer.textureGC.count),encoder.setPipeline(pipeline),encoder.renderPassEncoder.setBindGroup(1,gpuBindGroup),encoder.renderPassEncoder.drawIndexed(batch.size,1,batch.start)}}GpuBatchAdaptor.extension={type:[Extensions.Ag.WebGPUPipesAdaptor],name:"batch"};var AbstractRenderer=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"),SharedSystems=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs");class BindGroupSystem{constructor(renderer){this._hash=Object.create(null),this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_hash")}contextChange(gpu){this._gpu=gpu}getBindGroup(bindGroup,program,groupIndex){bindGroup._updateKey();return this._hash[bindGroup._key]||this._createBindGroup(bindGroup,program,groupIndex)}_createBindGroup(group,program,groupIndex){const device=this._gpu.device,groupLayout=program.layout[groupIndex],entries=[],renderer=this._renderer;for(const j in groupLayout){const resource=group.resources[j]??group.resources[groupLayout[j]];let gpuResource;if("uniformGroup"===resource._resourceType){const uniformGroup=resource;renderer.ubo.updateUniformGroup(uniformGroup);const buffer=uniformGroup.buffer;gpuResource={buffer:renderer.buffer.getGPUBuffer(buffer),offset:0,size:buffer.descriptor.size}}else if("buffer"===resource._resourceType){const buffer=resource;gpuResource={buffer:renderer.buffer.getGPUBuffer(buffer),offset:0,size:buffer.descriptor.size}}else if("bufferResource"===resource._resourceType){const bufferResource=resource;gpuResource={buffer:renderer.buffer.getGPUBuffer(bufferResource.buffer),offset:bufferResource.offset,size:bufferResource.size}}else if("textureSampler"===resource._resourceType){const sampler=resource;gpuResource=renderer.texture.getGpuSampler(sampler)}else if("textureSource"===resource._resourceType){const texture=resource;gpuResource=renderer.texture.getGpuSource(texture).createView({})}entries.push({binding:groupLayout[j],resource:gpuResource})}const layout=renderer.shader.getProgramData(program).bindGroups[groupIndex],gpuBindGroup=device.createBindGroup({layout,entries});return this._hash[group._key]=gpuBindGroup,gpuBindGroup}destroy(){for(const key of Object.keys(this._hash))this._hash[key]=null;this._hash=null,this._renderer=null}}BindGroupSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"bindGroup"};var fastCopy=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs");class GpuBufferSystem{constructor(renderer){this._gpuBuffers=Object.create(null),this._managedBuffers=[],renderer.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(gpu){this._gpu=gpu}getGPUBuffer(buffer){return this._gpuBuffers[buffer.uid]||this.createGPUBuffer(buffer)}updateBuffer(buffer){const gpuBuffer=this._gpuBuffers[buffer.uid]||this.createGPUBuffer(buffer),data=buffer.data;return buffer._updateID&&data&&(buffer._updateID=0,this._gpu.device.queue.writeBuffer(gpuBuffer,0,data.buffer,0,(buffer._updateSize||data.byteLength)+3&-4)),gpuBuffer}destroyAll(){for(const id in this._gpuBuffers)this._gpuBuffers[id].destroy();this._gpuBuffers={}}createGPUBuffer(buffer){this._gpuBuffers[buffer.uid]||(buffer.on("update",this.updateBuffer,this),buffer.on("change",this.onBufferChange,this),buffer.on("destroy",this.onBufferDestroy,this),this._managedBuffers.push(buffer));const gpuBuffer=this._gpu.device.createBuffer(buffer.descriptor);return buffer._updateID=0,buffer.data&&((0,fastCopy.W)(buffer.data.buffer,gpuBuffer.getMappedRange()),gpuBuffer.unmap()),this._gpuBuffers[buffer.uid]=gpuBuffer,gpuBuffer}onBufferChange(buffer){this._gpuBuffers[buffer.uid].destroy(),buffer._updateID=0,this._gpuBuffers[buffer.uid]=this.createGPUBuffer(buffer)}onBufferDestroy(buffer){this._managedBuffers.splice(this._managedBuffers.indexOf(buffer),1),this._destroyBuffer(buffer)}destroy(){this._managedBuffers.forEach(buffer=>this._destroyBuffer(buffer)),this._managedBuffers=null,this._gpuBuffers=null}_destroyBuffer(buffer){this._gpuBuffers[buffer.uid].destroy(),buffer.off("update",this.updateBuffer,this),buffer.off("change",this.onBufferChange,this),buffer.off("destroy",this.onBufferDestroy,this),this._gpuBuffers[buffer.uid]=null}}GpuBufferSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"buffer"};class GpuColorMaskSystem{constructor(renderer){this._colorMaskCache=15,this._renderer=renderer}setMask(colorMask){this._colorMaskCache!==colorMask&&(this._colorMaskCache=colorMask,this._renderer.pipeline.setColorMask(colorMask))}destroy(){this._renderer=null,this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"colorMask"};var environment_adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs");class GpuDeviceSystem{constructor(renderer){this._renderer=renderer}async init(options){return this._initPromise||(this._initPromise=this._createDeviceAndAdaptor(options).then(gpu=>{this.gpu=gpu,this._renderer.runners.contextChange.emit(this.gpu)})),this._initPromise}contextChange(gpu){this._renderer.gpu=gpu}async _createDeviceAndAdaptor(options){const adapter=await environment_adapter.e.get().getNavigator().gpu.requestAdapter({powerPreference:options.powerPreference,forceFallbackAdapter:options.forceFallbackAdapter}),requiredFeatures=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(feature=>adapter.features.has(feature)),device=await adapter.requestDevice({requiredFeatures});return{adapter,device}}destroy(){this.gpu=null,this._renderer=null}}GpuDeviceSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"device"},GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class GpuEncoderSystem{constructor(renderer){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=renderer}renderStart(){this.commandFinished=new Promise(resolve=>{this._resolveCommandFinished=resolve}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(gpuRenderTarget){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(viewport){this.renderPassEncoder.setViewport(viewport.x,viewport.y,viewport.width,viewport.height,0,1)}setPipelineFromGeometryProgramAndState(geometry,program,state,topology){const pipeline=this._renderer.pipeline.getPipeline(geometry,program,state,topology);this.setPipeline(pipeline)}setPipeline(pipeline){this._boundPipeline!==pipeline&&(this._boundPipeline=pipeline,this.renderPassEncoder.setPipeline(pipeline))}_setVertexBuffer(index,buffer){this._boundVertexBuffer[index]!==buffer&&(this._boundVertexBuffer[index]=buffer,this.renderPassEncoder.setVertexBuffer(index,this._renderer.buffer.updateBuffer(buffer)))}_setIndexBuffer(buffer){if(this._boundIndexBuffer===buffer)return;this._boundIndexBuffer=buffer;const indexFormat=2===buffer.data.BYTES_PER_ELEMENT?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer),indexFormat)}resetBindGroup(index){this._boundBindGroup[index]=null}setBindGroup(index,bindGroup,program){if(this._boundBindGroup[index]===bindGroup)return;this._boundBindGroup[index]=bindGroup,bindGroup._touch(this._renderer.textureGC.count);const gpuBindGroup=this._renderer.bindGroup.getBindGroup(bindGroup,program,index);this.renderPassEncoder.setBindGroup(index,gpuBindGroup)}setGeometry(geometry,program){const buffersToBind=this._renderer.pipeline.getBufferNamesToBind(geometry,program);for(const i in buffersToBind)this._setVertexBuffer(i,geometry.attributes[buffersToBind[i]].buffer);geometry.indexBuffer&&this._setIndexBuffer(geometry.indexBuffer)}_setShaderBindGroups(shader,skipSync){for(const i in shader.groups){const bindGroup=shader.groups[i];skipSync||this._syncBindGroup(bindGroup),this.setBindGroup(i,bindGroup,shader.gpuProgram)}}_syncBindGroup(bindGroup){for(const j in bindGroup.resources){const resource=bindGroup.resources[j];resource.isUniformGroup&&this._renderer.ubo.updateUniformGroup(resource)}}draw(options){const{geometry,shader,state,topology,size,start,instanceCount,skipSync}=options;this.setPipelineFromGeometryProgramAndState(geometry,shader.gpuProgram,state,topology),this.setGeometry(geometry,shader.gpuProgram),this._setShaderBindGroups(shader,skipSync),geometry.indexBuffer?this.renderPassEncoder.drawIndexed(size||geometry.indexBuffer.data.length,instanceCount??geometry.instanceCount,start||0):this.renderPassEncoder.draw(size||geometry.getSize(),instanceCount??geometry.instanceCount,start||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const descriptor=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(descriptor);const boundPipeline=this._boundPipeline,boundVertexBuffer={...this._boundVertexBuffer},boundIndexBuffer=this._boundIndexBuffer,boundBindGroup={...this._boundBindGroup};this._clearCache();const viewport=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(viewport.x,viewport.y,viewport.width,viewport.height,0,1),this.setPipeline(boundPipeline);for(const i in boundVertexBuffer)this._setVertexBuffer(i,boundVertexBuffer[i]);for(const i in boundBindGroup)this.setBindGroup(i,boundBindGroup[i],null);this._setIndexBuffer(boundIndexBuffer)}_clearCache(){for(let i=0;i<16;i++)this._boundBindGroup[i]=null,this._boundVertexBuffer[i]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(gpu){this._gpu=gpu}}GpuEncoderSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"encoder",priority:1};var state_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");class GpuStencilSystem{constructor(renderer){this._renderTargetStencilState=Object.create(null),this._renderer=renderer,renderer.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(renderTarget){let stencilState=this._renderTargetStencilState[renderTarget.uid];stencilState||(stencilState=this._renderTargetStencilState[renderTarget.uid]={stencilMode:state_const.K.DISABLED,stencilReference:0}),this._activeRenderTarget=renderTarget,this.setStencilMode(stencilState.stencilMode,stencilState.stencilReference)}setStencilMode(stencilMode,stencilReference){const stencilState=this._renderTargetStencilState[this._activeRenderTarget.uid];stencilState.stencilMode=stencilMode,stencilState.stencilReference=stencilReference;const renderer=this._renderer;renderer.pipeline.setStencilMode(stencilMode),renderer.encoder.renderPassEncoder.setStencilReference(stencilReference)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"stencil"};var UboSystem=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs");const WGSL_ALIGN_SIZE_DATA={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function createUboElementsWGSL(uniformData){const uboElements=uniformData.map(data=>({data,offset:0,size:0}));let offset=0;for(let i=0;i<uboElements.length;i++){const uboElement=uboElements[i];let size=WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;const align=WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;if(!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);uboElement.data.size>1&&(size=Math.max(size,align)*uboElement.data.size),offset=Math.ceil(offset/align)*align,uboElement.size=size,uboElement.offset=offset,offset+=size}return offset=16*Math.ceil(offset/16),{uboElements,size:offset}}var createUboSyncFunction=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"),uboSyncFunctions=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs");function generateArraySyncWGSL(uboElement,offsetToAdd){const{size,align}=WGSL_ALIGN_SIZE_DATA[uboElement.data.type],remainder=(align-size)/4,data=uboElement.data.type.indexOf("i32")>=0?"dataInt32":"data";return`\n         v = uv.${uboElement.data.name};\n         ${0!==offsetToAdd?`offset += ${offsetToAdd};`:""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size*(size/4)}; i++)\n         {\n             for(var j = 0; j < ${size/4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${0!==remainder?`arrayOffset += ${remainder};`:""}\n         }\n     `}function createUboSyncFunctionWGSL(uboElements){return(0,createUboSyncFunction.E)(uboElements,"uboWgsl",generateArraySyncWGSL,uboSyncFunctions._)}class GpuUboSystem extends UboSystem.W{constructor(){super({createUboElements:createUboElementsWGSL,generateUboSync:createUboSyncFunctionWGSL})}}GpuUboSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"ubo"};var Buffer=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),BufferResource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"),buffer_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");class UboBatch{constructor({minUniformOffsetAlignment}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=minUniformOffsetAlignment,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(size){if(size>this._minUniformOffsetAlignment/4)throw new Error("UniformBufferBatch: array is too large: "+4*size);const start=this.byteIndex;let newSize=start+4*size;if(newSize=Math.ceil(newSize/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,newSize>4*this.data.length)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=newSize,start}addGroup(array){const offset=this.addEmptyGroup(array.length);for(let i=0;i<array.length;i++)this.data[offset/4+i]=array[i];return offset}destroy(){this.data=null}}var BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");class GpuUniformBatchPipe{constructor(renderer){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_bindGroupHash"),this._batchBuffer=new UboBatch({minUniformOffsetAlignment:128});for(let i=0;i<2;i++){let usage=buffer_const.S.UNIFORM|buffer_const.S.COPY_DST;0===i&&(usage|=buffer_const.S.COPY_SRC),this._buffers.push(new Buffer.h({data:this._batchBuffer.data,usage}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const i in this._bindGroupHash)this._bindGroupHash[i]=null;this._batchBuffer.clear()}getUniformBindGroup(group,duplicate){if(!duplicate&&this._bindGroupHash[group.uid])return this._bindGroupHash[group.uid];this._renderer.ubo.ensureUniformGroup(group);const data=group.buffer.data,offset=this._batchBuffer.addEmptyGroup(data.length);return this._renderer.ubo.syncUniformGroup(group,this._batchBuffer.data,offset/4),this._bindGroupHash[group.uid]=this._getBindGroup(offset/128),this._bindGroupHash[group.uid]}getUboResource(group){this._renderer.ubo.updateUniformGroup(group);const data=group.buffer.data,offset=this._batchBuffer.addGroup(data);return this._getBufferResource(offset/128)}getArrayBindGroup(data){const offset=this._batchBuffer.addGroup(data);return this._getBindGroup(offset/128)}getArrayBufferResource(data){const index=this._batchBuffer.addGroup(data)/128;return this._getBufferResource(index)}_getBufferResource(index){if(!this._bufferResources[index]){const buffer=this._buffers[index%2];this._bufferResources[index]=new BufferResource.d({buffer,offset:256*(index/2|0),size:128})}return this._bufferResources[index]}_getBindGroup(index){if(!this._bindGroups[index]){const bindGroup=new BindGroup.T({0:this._getBufferResource(index)});this._bindGroups[index]=bindGroup}return this._bindGroups[index]}_uploadBindGroups(){const bufferSystem=this._renderer.buffer,firstBuffer=this._buffers[0];firstBuffer.update(this._batchBuffer.byteIndex),bufferSystem.updateBuffer(firstBuffer);const commandEncoder=this._renderer.gpu.device.createCommandEncoder();for(let i=1;i<this._buffers.length;i++){const buffer=this._buffers[i];commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer),128,bufferSystem.getGPUBuffer(buffer),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([commandEncoder.finish()])}destroy(){for(let i=0;i<this._bindGroups.length;i++)this._bindGroups[i].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let i=0;i<this._buffers.length;i++)this._buffers[i].destroy();this._buffers=null;for(let i=0;i<this._bufferResources.length;i++)this._bufferResources[i].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}GpuUniformBatchPipe.extension={type:[Extensions.Ag.WebGPUPipes],name:"uniformBatch"};var ensureAttributes=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"),createIdFromString=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"),GpuStencilModesToPixi=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs");const topologyStringToId={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};class PipelineSystem{constructor(renderer){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=renderer}contextChange(gpu){this._gpu=gpu,this.setStencilMode(state_const.K.DISABLED),this._updatePipeHash()}setMultisampleCount(multisampleCount){this._multisampleCount!==multisampleCount&&(this._multisampleCount=multisampleCount,this._updatePipeHash())}setRenderTarget(renderTarget){this._multisampleCount=renderTarget.msaaSamples,this._depthStencilAttachment=renderTarget.descriptor.depthStencilAttachment?1:0,this._updatePipeHash()}setColorMask(colorMask){this._colorMask!==colorMask&&(this._colorMask=colorMask,this._updatePipeHash())}setStencilMode(stencilMode){this._stencilMode!==stencilMode&&(this._stencilMode=stencilMode,this._stencilState=GpuStencilModesToPixi.g[stencilMode],this._updatePipeHash())}setPipeline(geometry,program,state,passEncoder){const pipeline=this.getPipeline(geometry,program,state);passEncoder.setPipeline(pipeline)}getPipeline(geometry,program,state,topology){geometry._layoutKey||((0,ensureAttributes.q)(geometry,program.attributeData),this._generateBufferKey(geometry)),topology||(topology=geometry.topology);const key=function getGraphicsStateKey(geometryLayout,shaderKey,state,blendMode,topology){return geometryLayout<<24|shaderKey<<16|state<<10|blendMode<<5|topology}(geometry._layoutKey,program._layoutKey,state.data,state._blendModeId,topologyStringToId[topology]);return this._pipeCache[key]||(this._pipeCache[key]=this._createPipeline(geometry,program,state,topology)),this._pipeCache[key]}_createPipeline(geometry,program,state,topology){const device=this._gpu.device,buffers=this._createVertexBufferLayouts(geometry,program),blendModes=this._renderer.state.getColorTargets(state);blendModes[0].writeMask=this._stencilMode===state_const.K.RENDERING_MASK_ADD?0:this._colorMask;const layout=this._renderer.shader.getProgramData(program).pipeline,descriptor={vertex:{module:this._getModule(program.vertex.source),entryPoint:program.vertex.entryPoint,buffers},fragment:{module:this._getModule(program.fragment.source),entryPoint:program.fragment.entryPoint,targets:blendModes},primitive:{topology,cullMode:state.cullMode},layout,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};this._depthStencilAttachment&&(descriptor.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:state.depthTest,depthCompare:state.depthTest?"less":"always"});return device.createRenderPipeline(descriptor)}_getModule(code){return this._moduleCache[code]||this._createModule(code)}_createModule(code){const device=this._gpu.device;return this._moduleCache[code]=device.createShaderModule({code}),this._moduleCache[code]}_generateBufferKey(geometry){const keyGen=[];let index=0;const attributeKeys=Object.keys(geometry.attributes).sort();for(let i=0;i<attributeKeys.length;i++){const attribute=geometry.attributes[attributeKeys[i]];keyGen[index++]=attribute.offset,keyGen[index++]=attribute.format,keyGen[index++]=attribute.stride,keyGen[index++]=attribute.instance}const stringKey=keyGen.join("|");return geometry._layoutKey=(0,createIdFromString.X)(stringKey,"geometry"),geometry._layoutKey}_generateAttributeLocationsKey(program){const keyGen=[];let index=0;const attributeKeys=Object.keys(program.attributeData).sort();for(let i=0;i<attributeKeys.length;i++){const attribute=program.attributeData[attributeKeys[i]];keyGen[index++]=attribute.location}const stringKey=keyGen.join("|");return program._attributeLocationsKey=(0,createIdFromString.X)(stringKey,"programAttributes"),program._attributeLocationsKey}getBufferNamesToBind(geometry,program){const key=geometry._layoutKey<<16|program._attributeLocationsKey;if(this._bindingNamesCache[key])return this._bindingNamesCache[key];const data=this._createVertexBufferLayouts(geometry,program),bufferNamesToBind=Object.create(null),attributeData=program.attributeData;for(let i=0;i<data.length;i++){const shaderLocation=Object.values(data[i].attributes)[0].shaderLocation;for(const j in attributeData)if(attributeData[j].location===shaderLocation){bufferNamesToBind[i]=j;break}}return this._bindingNamesCache[key]=bufferNamesToBind,bufferNamesToBind}_createVertexBufferLayouts(geometry,program){program._attributeLocationsKey||this._generateAttributeLocationsKey(program);const key=geometry._layoutKey<<16|program._attributeLocationsKey;if(this._bufferLayoutsCache[key])return this._bufferLayoutsCache[key];const vertexBuffersLayout=[];return geometry.buffers.forEach(buffer=>{const bufferEntry={arrayStride:0,stepMode:"vertex",attributes:[]},bufferEntryAttributes=bufferEntry.attributes;for(const i in program.attributeData){const attribute=geometry.attributes[i];1!==(attribute.divisor??1)&&(0,warn.R)(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`),attribute.buffer===buffer&&(bufferEntry.arrayStride=attribute.stride,bufferEntry.stepMode=attribute.instance?"instance":"vertex",bufferEntryAttributes.push({shaderLocation:program.attributeData[i].location,offset:attribute.offset,format:attribute.format}))}bufferEntryAttributes.length&&vertexBuffersLayout.push(bufferEntry)}),this._bufferLayoutsCache[key]=vertexBuffersLayout,vertexBuffersLayout}_updatePipeHash(){const key=function getGlobalStateKey(stencilStateId,multiSampleCount,colorMask,renderTarget){return colorMask<<6|stencilStateId<<3|renderTarget<<1|multiSampleCount}(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment);this._pipeStateCaches[key]||(this._pipeStateCaches[key]=Object.create(null)),this._pipeCache=this._pipeStateCaches[key]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"pipeline"};var RenderTargetSystem=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"),gl_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"),CanvasSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"),TextureSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");class GpuRenderTarget{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class GpuRenderTargetAdaptor{init(renderer,renderTargetSystem){this._renderer=renderer,this._renderTargetSystem=renderTargetSystem}copyToTexture(sourceRenderSurfaceTexture,destinationTexture,originSrc,size,originDest){const renderer=this._renderer,baseGpuTexture=this._getGpuColorTexture(sourceRenderSurfaceTexture),backGpuTexture=renderer.texture.getGpuSource(destinationTexture.source);return renderer.encoder.commandEncoder.copyTextureToTexture({texture:baseGpuTexture,origin:originSrc},{texture:backGpuTexture,origin:originDest},size),destinationTexture}startRenderPass(renderTarget,clear=!0,clearColor,viewport){const gpuRenderTarget=this._renderTargetSystem.getGpuRenderTarget(renderTarget),descriptor=this.getDescriptor(renderTarget,clear,clearColor);gpuRenderTarget.descriptor=descriptor,this._renderer.pipeline.setRenderTarget(gpuRenderTarget),this._renderer.encoder.beginRenderPass(gpuRenderTarget),this._renderer.encoder.setViewport(viewport)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(renderTarget){const gpuRenderTarget=this._renderTargetSystem.getGpuRenderTarget(renderTarget);return gpuRenderTarget.contexts[0]?gpuRenderTarget.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source)}getDescriptor(renderTarget,clear,clearValue){"boolean"==typeof clear&&(clear=clear?gl_const.u.ALL:gl_const.u.NONE);const renderTargetSystem=this._renderTargetSystem,gpuRenderTarget=renderTargetSystem.getGpuRenderTarget(renderTarget),colorAttachments=renderTarget.colorTextures.map((texture,i)=>{const context=gpuRenderTarget.contexts[i];let view,resolveTarget;if(context){view=context.getCurrentTexture().createView()}else view=this._renderer.texture.getGpuSource(texture).createView({mipLevelCount:1});gpuRenderTarget.msaaTextures[i]&&(resolveTarget=view,view=this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i]));const loadOp=clear&gl_const.u.COLOR?"clear":"load";return clearValue??(clearValue=renderTargetSystem.defaultClearColor),{view,resolveTarget,clearValue,storeOp:"store",loadOp}});let depthStencilAttachment;if(!renderTarget.stencil&&!renderTarget.depth||renderTarget.depthStencilTexture||(renderTarget.ensureDepthStencilTexture(),renderTarget.depthStencilTexture.source.sampleCount=gpuRenderTarget.msaa?4:1),renderTarget.depthStencilTexture){const stencilLoadOp=clear&gl_const.u.STENCIL?"clear":"load",depthLoadOp=clear&gl_const.u.DEPTH?"clear":"load";depthStencilAttachment={view:this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp,depthClearValue:1,depthLoadOp,depthStoreOp:"store"}}return{colorAttachments,depthStencilAttachment}}clear(renderTarget,clear=!0,clearColor,viewport){if(!clear)return;const{gpu,encoder}=this._renderer,device=gpu.device;if(null===encoder.commandEncoder){const commandEncoder=device.createCommandEncoder(),renderPassDescriptor=this.getDescriptor(renderTarget,clear,clearColor),passEncoder=commandEncoder.beginRenderPass(renderPassDescriptor);passEncoder.setViewport(viewport.x,viewport.y,viewport.width,viewport.height,0,1),passEncoder.end();const gpuCommands=commandEncoder.finish();device.queue.submit([gpuCommands])}else this.startRenderPass(renderTarget,clear,clearColor,viewport)}initGpuRenderTarget(renderTarget){renderTarget.isRoot=!0;const gpuRenderTarget=new GpuRenderTarget;return renderTarget.colorTextures.forEach((colorTexture,i)=>{if(CanvasSource.q.test(colorTexture.resource)){const context=colorTexture.resource.getContext("webgpu"),alphaMode=colorTexture.transparent?"premultiplied":"opaque";try{context.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode})}catch(e){console.error(e)}gpuRenderTarget.contexts[i]=context}if(gpuRenderTarget.msaa=colorTexture.source.antialias,colorTexture.source.antialias){const msaaTexture=new TextureSource.v({width:0,height:0,sampleCount:4});gpuRenderTarget.msaaTextures[i]=msaaTexture}}),gpuRenderTarget.msaa&&(gpuRenderTarget.msaaSamples=4,renderTarget.depthStencilTexture&&(renderTarget.depthStencilTexture.source.sampleCount=4)),gpuRenderTarget}destroyGpuRenderTarget(gpuRenderTarget){gpuRenderTarget.contexts.forEach(context=>{context.unconfigure()}),gpuRenderTarget.msaaTextures.forEach(texture=>{texture.destroy()}),gpuRenderTarget.msaaTextures.length=0,gpuRenderTarget.contexts.length=0}ensureDepthStencilTexture(renderTarget){const gpuRenderTarget=this._renderTargetSystem.getGpuRenderTarget(renderTarget);renderTarget.depthStencilTexture&&gpuRenderTarget.msaa&&(renderTarget.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(renderTarget){const gpuRenderTarget=this._renderTargetSystem.getGpuRenderTarget(renderTarget);gpuRenderTarget.width=renderTarget.width,gpuRenderTarget.height=renderTarget.height,gpuRenderTarget.msaa&&renderTarget.colorTextures.forEach((colorTexture,i)=>{const msaaTexture=gpuRenderTarget.msaaTextures[i];msaaTexture?.resize(colorTexture.source.width,colorTexture.source.height,colorTexture.source._resolution)})}}class GpuRenderTargetSystem extends RenderTargetSystem.l{constructor(renderer){super(renderer),this.adaptor=new GpuRenderTargetAdaptor,this.adaptor.init(renderer,this)}}GpuRenderTargetSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"renderTarget"};class GpuShaderSystem{constructor(){this._gpuProgramData=Object.create(null)}contextChange(gpu){this._gpu=gpu,this.maxTextures=gpu.device.limits.maxSampledTexturesPerShaderStage}getProgramData(program){return this._gpuProgramData[program._layoutKey]||this._createGPUProgramData(program)}_createGPUProgramData(program){const device=this._gpu.device,bindGroups=program.gpuLayout.map(group=>device.createBindGroupLayout({entries:group})),pipelineLayoutDesc={bindGroupLayouts:bindGroups};return this._gpuProgramData[program._layoutKey]={bindGroups,pipeline:device.createPipelineLayout(pipelineLayoutDesc)},this._gpuProgramData[program._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}GpuShaderSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"shader"};const GpuBlendModesToPixi={normal:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},add:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},multiply:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},screen:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},overlay:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},none:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},"normal-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},"add-npm":{alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},"screen-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},erase:{alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}},min:{alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}},max:{alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}}};class GpuStateSystem{constructor(){this.defaultState=new State.U,this.defaultState.blend=!0}contextChange(gpu){this.gpu=gpu}getColorTargets(state){return[{format:"bgra8unorm",writeMask:0,blend:GpuBlendModesToPixi[state.blendMode]||GpuBlendModesToPixi.normal}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"state"};var CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");const gpuUploadBufferImageResource={type:"image",upload(source,gpuTexture,gpu){const resource=source.resource,total=(0|source.pixelWidth)*(0|source.pixelHeight),bytesPerPixel=resource.byteLength/total;gpu.device.queue.writeTexture({texture:gpuTexture},resource,{offset:0,rowsPerImage:source.pixelHeight,bytesPerRow:source.pixelHeight*bytesPerPixel},{width:source.pixelWidth,height:source.pixelHeight,depthOrArrayLayers:1})}},blockDataMap={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},defaultBlockData={blockBytes:4,blockWidth:1,blockHeight:1},gpuUploadCompressedTextureResource={type:"compressed",upload(source,gpuTexture,gpu){let mipWidth=source.pixelWidth,mipHeight=source.pixelHeight;const blockData=blockDataMap[source.format]||defaultBlockData;for(let i=0;i<source.resource.length;i++){const levelBuffer=source.resource[i],bytesPerRow=Math.ceil(mipWidth/blockData.blockWidth)*blockData.blockBytes;gpu.device.queue.writeTexture({texture:gpuTexture,mipLevel:i},levelBuffer,{offset:0,bytesPerRow},{width:Math.ceil(mipWidth/blockData.blockWidth)*blockData.blockWidth,height:Math.ceil(mipHeight/blockData.blockHeight)*blockData.blockHeight,depthOrArrayLayers:1}),mipWidth=Math.max(mipWidth>>1,1),mipHeight=Math.max(mipHeight>>1,1)}}},gpuUploadImageResource={type:"image",upload(source,gpuTexture,gpu){const resource=source.resource;if(!resource)return;const width=Math.min(gpuTexture.width,source.resourceWidth||source.pixelWidth),height=Math.min(gpuTexture.height,source.resourceHeight||source.pixelHeight),premultipliedAlpha="premultiply-alpha-on-upload"===source.alphaMode;gpu.device.queue.copyExternalImageToTexture({source:resource},{texture:gpuTexture,premultipliedAlpha},{width,height})}},gpuUploadVideoResource={type:"video",upload(source,gpuTexture,gpu){gpuUploadImageResource.upload(source,gpuTexture,gpu)}};class GpuMipmapGenerator{constructor(device){this.device=device,this.sampler=device.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(format){let pipeline=this.pipelines[format];return pipeline||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:"\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "})),pipeline=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format}]}}),this.pipelines[format]=pipeline),pipeline}generateMipmap(texture){const pipeline=this._getMipmapPipeline(texture.format);if("3d"===texture.dimension||"1d"===texture.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let mipTexture=texture;const arrayLayerCount=texture.depthOrArrayLayers||1,renderToSource=texture.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!renderToSource){const mipTextureDescriptor={size:{width:Math.ceil(texture.width/2),height:Math.ceil(texture.height/2),depthOrArrayLayers:arrayLayerCount},format:texture.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:texture.mipLevelCount-1};mipTexture=this.device.createTexture(mipTextureDescriptor)}const commandEncoder=this.device.createCommandEncoder({}),bindGroupLayout=pipeline.getBindGroupLayout(0);for(let arrayLayer=0;arrayLayer<arrayLayerCount;++arrayLayer){let srcView=texture.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:arrayLayer,arrayLayerCount:1}),dstMipLevel=renderToSource?1:0;for(let i=1;i<texture.mipLevelCount;++i){const dstView=mipTexture.createView({baseMipLevel:dstMipLevel++,mipLevelCount:1,dimension:"2d",baseArrayLayer:arrayLayer,arrayLayerCount:1}),passEncoder=commandEncoder.beginRenderPass({colorAttachments:[{view:dstView,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),bindGroup=this.device.createBindGroup({layout:bindGroupLayout,entries:[{binding:0,resource:this.sampler},{binding:1,resource:srcView}]});passEncoder.setPipeline(pipeline),passEncoder.setBindGroup(0,bindGroup),passEncoder.draw(3,1,0,0),passEncoder.end(),srcView=dstView}}if(!renderToSource){const mipLevelSize={width:Math.ceil(texture.width/2),height:Math.ceil(texture.height/2),depthOrArrayLayers:arrayLayerCount};for(let i=1;i<texture.mipLevelCount;++i)commandEncoder.copyTextureToTexture({texture:mipTexture,mipLevel:i-1},{texture,mipLevel:i},mipLevelSize),mipLevelSize.width=Math.ceil(mipLevelSize.width/2),mipLevelSize.height=Math.ceil(mipLevelSize.height/2)}return this.device.queue.submit([commandEncoder.finish()]),renderToSource||mipTexture.destroy(),texture}}class GpuTextureSystem{constructor(renderer){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:gpuUploadImageResource,buffer:gpuUploadBufferImageResource,video:gpuUploadVideoResource,compressed:gpuUploadCompressedTextureResource},this._renderer=renderer,renderer.renderableGC.addManagedHash(this,"_gpuSources"),renderer.renderableGC.addManagedHash(this,"_gpuSamplers"),renderer.renderableGC.addManagedHash(this,"_bindGroupHash"),renderer.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(gpu){this._gpu=gpu}initSource(source){if(source.autoGenerateMipmaps){const biggestDimension=Math.max(source.pixelWidth,source.pixelHeight);source.mipLevelCount=Math.floor(Math.log2(biggestDimension))+1}let usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;"compressed"!==source.uploadMethodId&&(usage|=GPUTextureUsage.RENDER_ATTACHMENT,usage|=GPUTextureUsage.COPY_SRC);const blockData=blockDataMap[source.format]||{blockBytes:4,blockWidth:1,blockHeight:1},width=Math.ceil(source.pixelWidth/blockData.blockWidth)*blockData.blockWidth,height=Math.ceil(source.pixelHeight/blockData.blockHeight)*blockData.blockHeight,textureDescriptor={label:source.label,size:{width,height},format:source.format,sampleCount:source.sampleCount,mipLevelCount:source.mipLevelCount,dimension:source.dimension,usage},gpuTexture=this._gpu.device.createTexture(textureDescriptor);return this._gpuSources[source.uid]=gpuTexture,this.managedTextures.includes(source)||(source.on("update",this.onSourceUpdate,this),source.on("resize",this.onSourceResize,this),source.on("destroy",this.onSourceDestroy,this),source.on("unload",this.onSourceUnload,this),source.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(source)),this.onSourceUpdate(source),gpuTexture}onSourceUpdate(source){const gpuTexture=this.getGpuSource(source);gpuTexture&&(this._uploads[source.uploadMethodId]&&this._uploads[source.uploadMethodId].upload(source,gpuTexture,this._gpu),source.autoGenerateMipmaps&&source.mipLevelCount>1&&this.onUpdateMipmaps(source))}onSourceUnload(source){const gpuTexture=this._gpuSources[source.uid];gpuTexture&&(this._gpuSources[source.uid]=null,gpuTexture.destroy())}onUpdateMipmaps(source){this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device));const gpuTexture=this.getGpuSource(source);this._mipmapGenerator.generateMipmap(gpuTexture)}onSourceDestroy(source){source.off("update",this.onSourceUpdate,this),source.off("unload",this.onSourceUnload,this),source.off("destroy",this.onSourceDestroy,this),source.off("resize",this.onSourceResize,this),source.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(source),1),this.onSourceUnload(source)}onSourceResize(source){const gpuTexture=this._gpuSources[source.uid];gpuTexture?gpuTexture.width===source.pixelWidth&&gpuTexture.height===source.pixelHeight||(this._textureViewHash[source.uid]=null,this._bindGroupHash[source.uid]=null,this.onSourceUnload(source),this.initSource(source)):this.initSource(source)}_initSampler(sampler){return this._gpuSamplers[sampler._resourceId]=this._gpu.device.createSampler(sampler),this._gpuSamplers[sampler._resourceId]}getGpuSampler(sampler){return this._gpuSamplers[sampler._resourceId]||this._initSampler(sampler)}getGpuSource(source){return this._gpuSources[source.uid]||this.initSource(source)}getTextureBindGroup(texture){return this._bindGroupHash[texture.uid]??this._createTextureBindGroup(texture)}_createTextureBindGroup(texture){const source=texture.source;return this._bindGroupHash[texture.uid]=new BindGroup.T({0:source,1:source.style,2:new UniformGroup.k({uTextureMatrix:{type:"mat3x3<f32>",value:texture.textureMatrix.mapCoord}})}),this._bindGroupHash[texture.uid]}getTextureView(texture){const source=texture.source;return this._textureViewHash[source.uid]??this._createTextureView(source)}_createTextureView(texture){return this._textureViewHash[texture.uid]=this.getGpuSource(texture).createView(),this._textureViewHash[texture.uid]}generateCanvas(texture){const renderer=this._renderer,commandEncoder=renderer.gpu.device.createCommandEncoder(),canvas=environment_adapter.e.get().createCanvas();canvas.width=texture.source.pixelWidth,canvas.height=texture.source.pixelHeight;const context=canvas.getContext("webgpu");return context.configure({device:renderer.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:environment_adapter.e.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),commandEncoder.copyTextureToTexture({texture:renderer.texture.getGpuSource(texture.source),origin:{x:0,y:0}},{texture:context.getCurrentTexture()},{width:canvas.width,height:canvas.height}),renderer.gpu.device.queue.submit([commandEncoder.finish()]),canvas}getPixels(texture){const webGPUCanvas=this.generateCanvas(texture),canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(webGPUCanvas.width,webGPUCanvas.height),context=canvasAndContext.context;context.drawImage(webGPUCanvas,0,0);const{width,height}=webGPUCanvas,imageData=context.getImageData(0,0,width,height),pixels=new Uint8ClampedArray(imageData.data.buffer);return CanvasPool.N.returnCanvasAndContext(canvasAndContext),{pixels,width,height}}destroy(){this.managedTextures.slice().forEach(source=>this.onSourceDestroy(source)),this.managedTextures=null;for(const k of Object.keys(this._bindGroupHash)){const key=Number(k),bindGroup=this._bindGroupHash[key];bindGroup?.destroy(),this._bindGroupHash[key]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}GpuTextureSystem.extension={type:[Extensions.Ag.WebGPUSystem],name:"texture"};const DefaultWebGPUSystems=[...SharedSystems.i,GpuUboSystem,GpuEncoderSystem,GpuDeviceSystem,GpuBufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem],DefaultWebGPUPipes=[...SharedSystems.f,GpuUniformBatchPipe],DefaultWebGPUAdapters=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor],systems=[],renderPipes=[],renderPipeAdaptors=[];Extensions.XO.handleByNamedList(Extensions.Ag.WebGPUSystem,systems),Extensions.XO.handleByNamedList(Extensions.Ag.WebGPUPipes,renderPipes),Extensions.XO.handleByNamedList(Extensions.Ag.WebGPUPipesAdaptor,renderPipeAdaptors),Extensions.XO.add(...DefaultWebGPUSystems,...DefaultWebGPUPipes,...DefaultWebGPUAdapters);class WebGPURenderer extends AbstractRenderer.k{constructor(){super({name:"webgpu",type:types.W.WEBGPU,systems,renderPipes,renderPipeAdaptors})}}}}]);