"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[7798],{"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{I:()=>compileHighShaderGlProgram,v:()=>compileHighShaderGpuProgram});var GlProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),GpuProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");function addBits(srcParts,parts,name){if(srcParts)for(const i in srcParts){const part=parts[i.toLocaleLowerCase()];if(part){let sanitisedPart=srcParts[i];"header"===i&&(sanitisedPart=sanitisedPart.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),name&&part.push(`//----${name}----//`),part.push(sanitisedPart)}else(0,warn.R)(`${i} placement hook does not exist in shader`)}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(programSrc){const parts={};return(programSrc.match(findHooksRx)?.map((hook=>hook.replace(/[{()}]/g,"")))??[]).forEach((hook=>{parts[hook]=[]})),parts}function extractInputs(fragmentSource,out){let match;const regex=/@in\s+([^;]+);/g;for(;null!==(match=regex.exec(fragmentSource));)out.push(match[1])}function compileInputs(fragments,template,sort=!1){const results=[];extractInputs(template,results),fragments.forEach((fragment=>{fragment.header&&extractInputs(fragment.header,results)}));const mainInput=results;sort&&mainInput.sort();const finalString=mainInput.map(((inValue,i)=>`       @location(${i}) ${inValue},`)).join("\n");let cleanedString=template.replace(/@in\s+[^;]+;\s*/g,"");return cleanedString=cleanedString.replace("{{in}}",`\n${finalString}\n`),cleanedString}function extractOutputs(fragmentSource,out){let match;const regex=/@out\s+([^;]+);/g;for(;null!==(match=regex.exec(fragmentSource));)out.push(match[1])}function injectBits(templateSrc,fragmentParts){let out=templateSrc;for(const i in fragmentParts){const parts=fragmentParts[i];out=parts.join("\n").length?out.replace(`{{${i}}}`,`//-----${i} START-----//\n${parts.join("\n")}\n//----${i} FINISH----//`):out.replace(`{{${i}}}`,"")}return out}const cacheMap=Object.create(null),bitCacheMap=new Map;let CACHE_UID=0;function compileHighShader({template,bits}){const cacheId=generateCacheId(template,bits);if(cacheMap[cacheId])return cacheMap[cacheId];const{vertex,fragment}=function compileInputsAndOutputs(template,bits){const vertexFragments=bits.map((shaderBit=>shaderBit.vertex)).filter((v=>!!v)),fragmentFragments=bits.map((shaderBit=>shaderBit.fragment)).filter((v=>!!v));let compiledVertex=compileInputs(vertexFragments,template.vertex,!0);compiledVertex=function compileOutputs(fragments,template){const results=[];extractOutputs(template,results),fragments.forEach((fragment=>{fragment.header&&extractOutputs(fragment.header,results)}));let index=0;const mainStruct=results.sort().map((inValue=>inValue.indexOf("builtin")>-1?inValue:`@location(${index++}) ${inValue}`)).join(",\n"),mainStart=results.sort().map((inValue=>`       var ${function stripVariable(value){return value.replace(/@.*?\s+/g,"")}(inValue)};`)).join("\n"),mainEnd=`return VSOutput(\n                ${results.sort().map((inValue=>` ${function extractVariableName(value){const match=/\b(\w+)\s*:/g.exec(value);return match?match[1]:""}(inValue)}`)).join(",\n")});`;let compiledCode=template.replace(/@out\s+[^;]+;\s*/g,"");return compiledCode=compiledCode.replace("{{struct}}",`\n${mainStruct}\n`),compiledCode=compiledCode.replace("{{start}}",`\n${mainStart}\n`),compiledCode=compiledCode.replace("{{return}}",`\n${mainEnd}\n`),compiledCode}(vertexFragments,compiledVertex);const compiledFragment=compileInputs(fragmentFragments,template.fragment,!0);return{vertex:compiledVertex,fragment:compiledFragment}}(template,bits);return cacheMap[cacheId]=compileBits(vertex,fragment,bits),cacheMap[cacheId]}function compileHighShaderGl({template,bits}){const cacheId=generateCacheId(template,bits);return cacheMap[cacheId]||(cacheMap[cacheId]=compileBits(template.vertex,template.fragment,bits)),cacheMap[cacheId]}function generateCacheId(template,bits){return bits.map((highFragment=>(bitCacheMap.has(highFragment)||bitCacheMap.set(highFragment,CACHE_UID++),bitCacheMap.get(highFragment)))).sort(((a,b)=>a-b)).join("-")+template.vertex+template.fragment}function compileBits(vertex,fragment,bits){const vertexParts=compileHooks(vertex),fragmentParts=compileHooks(fragment);return bits.forEach((shaderBit=>{addBits(shaderBit.vertex,vertexParts,shaderBit.name),addBits(shaderBit.fragment,fragmentParts,shaderBit.name)})),{vertex:injectBits(vertex,vertexParts),fragment:injectBits(fragment,fragmentParts)}}const vertexGPUTemplate="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",fragmentGPUTemplate="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",vertexGlTemplate="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",fragmentGlTemplate="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",globalUniformsBit={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function compileHighShaderGpuProgram({bits,name}){const source=compileHighShader({template:{fragment:fragmentGPUTemplate,vertex:vertexGPUTemplate},bits:[globalUniformsBit,...bits]});return GpuProgram.B.from({name,vertex:{source:source.vertex,entryPoint:"main"},fragment:{source:source.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits,name}){return new GlProgram.M({name,...compileHighShaderGl({template:{vertex:vertexGlTemplate,fragment:fragmentGlTemplate},bits:[globalUniformsBitGl,...bits]})})}},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{F:()=>colorBit,a:()=>colorBitGl});const colorBit={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},colorBitGl={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{P:()=>generateTextureBatchBitGl,_:()=>generateTextureBatchBit});const textureBatchBitGpuCache={};function generateBindingSrc(maxTextures){const src=[];if(1===maxTextures)src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),src.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let bindingIndex=0;for(let i=0;i<maxTextures;i++)src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i+1}: texture_2d<f32>;`),src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i+1}: sampler;`)}return src.join("\n")}function generateSampleSrc(maxTextures){const src=[];if(1===maxTextures)src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{src.push("switch vTextureId {");for(let i=0;i<maxTextures;i++)i===maxTextures-1?src.push("  default:{"):src.push(`  case ${i}:{`),src.push(`      outColor = textureSampleGrad(textureSource${i+1}, textureSampler${i+1}, vUV, uvDx, uvDy);`),src.push("      break;}");src.push("}")}return src.join("\n")}function generateTextureBatchBit(maxTextures){return textureBatchBitGpuCache[maxTextures]||(textureBatchBitGpuCache[maxTextures]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `}}),textureBatchBitGpuCache[maxTextures]}const textureBatchBitGlCache={};function generateSampleGlSrc(maxTextures){const src=[];for(let i=0;i<maxTextures;i++)i>0&&src.push("else"),i<maxTextures-1&&src.push(`if(vTextureId < ${i}.5)`),src.push("{"),src.push(`\toutColor = texture(uTextures[${i}], vUV);`),src.push("}");return src.join("\n")}function generateTextureBatchBitGl(maxTextures){return textureBatchBitGlCache[maxTextures]||(textureBatchBitGlCache[maxTextures]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,main:`\n    \n                ${generateSampleGlSrc(16)}\n            `}}),textureBatchBitGlCache[maxTextures]}},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ls:()=>localUniformBit,_Q:()=>localUniformBitGroup2,mA:()=>localUniformBitGl});const localUniformBit={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>roundPixelsBit,m:()=>roundPixelsBitGl});const roundPixelsBit={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{M:()=>GlProgram});var createIdFromString=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs");let context,maxFragmentPrecision;function getMaxFragmentPrecision(){if(!maxFragmentPrecision){maxFragmentPrecision="mediump";const gl=function getTestContext(){if(!context||context?.isContextLost()){const canvas=adapter.e.get().createCanvas();context=canvas.getContext("webgl",{})}return context}();if(gl&&gl.getShaderPrecisionFormat){const shaderFragment=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT);maxFragmentPrecision=shaderFragment.precision?"highp":"mediump"}}return maxFragmentPrecision}const fragmentNameCache={},VertexNameCache={};const processes={stripVersion:function stripVersion(src,isES300){return isES300?src.replace("#version 300 es",""):src},ensurePrecision:function ensurePrecision(src,options,isFragment){const maxSupportedPrecision=isFragment?options.maxSupportedFragmentPrecision:options.maxSupportedVertexPrecision;if("precision"!==src.substring(0,9)){let precision=isFragment?options.requestedFragmentPrecision:options.requestedVertexPrecision;return"highp"===precision&&"highp"!==maxSupportedPrecision&&(precision="mediump"),`precision ${precision} float;\n${src}`}return"highp"!==maxSupportedPrecision&&"precision highp"===src.substring(0,15)?src.replace("precision highp","precision mediump"):src},addProgramDefines:function addProgramDefines(src,isES300,isFragment){return isES300?src:isFragment?`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src=src.replace("out vec4 finalColor;","")}\n        `:`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `},setProgramName:function setProgramName(src,{name="pixi-program"},isFragment=!0){name=name.replace(/\s+/g,"-");const nameCache=isFragment?fragmentNameCache:VertexNameCache;return nameCache[name+=isFragment?"-fragment":"-vertex"]?(nameCache[name]++,name+=`-${nameCache[name]}`):nameCache[name]=1,-1!==src.indexOf("#define SHADER_NAME")?src:`${`#define SHADER_NAME ${name}`}\n${src}`},insertVersion:function insertVersion(src,isES300){return isES300?`#version 300 es\n${src}`:src}},programCache=Object.create(null),_GlProgram=class _GlProgram{constructor(options){const isES300=-1!==(options={..._GlProgram.defaultOptions,...options}).fragment.indexOf("#version 300 es"),preprocessorOptions={stripVersion:isES300,ensurePrecision:{requestedFragmentPrecision:options.preferredFragmentPrecision,requestedVertexPrecision:options.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:options.name},addProgramDefines:isES300,insertVersion:isES300};let fragment=options.fragment,vertex=options.vertex;Object.keys(processes).forEach((processKey=>{const processOptions=preprocessorOptions[processKey];fragment=processes[processKey](fragment,processOptions,!0),vertex=processes[processKey](vertex,processOptions,!1)})),this.fragment=fragment,this.vertex=vertex,this._key=(0,createIdFromString.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(options){const key=`${options.vertex}:${options.fragment}`;return programCache[key]||(programCache[key]=new _GlProgram(options)),programCache[key]}};_GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let GlProgram=_GlProgram},"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{B:()=>GpuProgram});var createIdFromString=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"),getAttributeInfoFromFormat=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");const WGSL_TO_VERTEX_TYPES={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function extractStructAndGroups(wgsl){const groupPattern=/@group\((\d+)\)/,bindingPattern=/@binding\((\d+)\)/,namePattern=/var(<[^>]+>)? (\w+)/,typePattern=/:\s*(\w+)/,structMemberPattern=/(\w+)\s*:\s*([\w\<\>]+)/g,structName=/struct\s+(\w+)/,groups=wgsl.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map((item=>({group:parseInt(item.match(groupPattern)[1],10),binding:parseInt(item.match(bindingPattern)[1],10),name:item.match(namePattern)[2],isUniform:"<uniform>"===item.match(namePattern)[1],type:item.match(typePattern)[1]})));if(!groups)return{groups:[],structs:[]};const structs=wgsl.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map((struct=>{const name=struct.match(structName)[1],members=struct.match(structMemberPattern).reduce(((acc,member)=>{const[name2,type]=member.split(":");return acc[name2.trim()]=type.trim(),acc}),{});return members?{name,members}:null})).filter((({name})=>groups.some((group=>group.type===name))))??[];return{groups,structs}}var ShaderStage=(ShaderStage2=>(ShaderStage2[ShaderStage2.VERTEX=1]="VERTEX",ShaderStage2[ShaderStage2.FRAGMENT=2]="FRAGMENT",ShaderStage2[ShaderStage2.COMPUTE=4]="COMPUTE",ShaderStage2))(ShaderStage||{});const programCache=Object.create(null);class GpuProgram{constructor(options){this._layoutKey=0;const{fragment,vertex,layout,gpuLayout,name}=options;if(this.name=name,this.fragment=fragment,this.vertex=vertex,fragment.source===vertex.source){const structsAndGroups=extractStructAndGroups(fragment.source);this.structsAndGroups=structsAndGroups}else{const vertexStructsAndGroups=extractStructAndGroups(vertex.source),fragmentStructsAndGroups=extractStructAndGroups(fragment.source);this.structsAndGroups=function removeStructAndGroupDuplicates(vertexStructsAndGroups,fragmentStructsAndGroups){const structNameSet=new Set,dupeGroupKeySet=new Set;return{structs:[...vertexStructsAndGroups.structs,...fragmentStructsAndGroups.structs].filter((struct=>!structNameSet.has(struct.name)&&(structNameSet.add(struct.name),!0))),groups:[...vertexStructsAndGroups.groups,...fragmentStructsAndGroups.groups].filter((group=>{const key=`${group.name}-${group.binding}`;return!dupeGroupKeySet.has(key)&&(dupeGroupKeySet.add(key),!0)}))}}(vertexStructsAndGroups,fragmentStructsAndGroups)}this.layout=layout??function generateLayoutHash({groups}){const layout=[];for(let i=0;i<groups.length;i++){const group=groups[i];layout[group.group]||(layout[group.group]={}),layout[group.group][group.name]=group.binding}return layout}(this.structsAndGroups),this.gpuLayout=gpuLayout??function generateGpuLayoutGroups({groups}){const layout=[];for(let i=0;i<groups.length;i++){const group=groups[i];layout[group.group]||(layout[group.group]=[]),group.isUniform?layout[group.group].push({binding:group.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===group.type?layout[group.group].push({binding:group.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===group.type&&layout[group.group].push({binding:group.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return layout}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex,fragment}=this,bigKey=vertex.source+fragment.source+vertex.entryPoint+fragment.entryPoint;this._layoutKey=(0,createIdFromString.X)(bigKey,"program")}get attributeData(){return this._attributeData??(this._attributeData=function extractAttributesFromGpuProgram({source,entryPoint}){const results={},mainVertStart=source.indexOf(`fn ${entryPoint}`);if(-1!==mainVertStart){const arrowFunctionStart=source.indexOf("->",mainVertStart);if(-1!==arrowFunctionStart){const functionArgsSubstring=source.substring(mainVertStart,arrowFunctionStart),inputsRegex=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let match;for(;null!==(match=inputsRegex.exec(functionArgsSubstring));){const format=WGSL_TO_VERTEX_TYPES[match[3]]??"float32";results[match[2]]={location:parseInt(match[1],10),format,stride:(0,getAttributeInfoFromFormat.m)(format).stride,offset:0,instance:!1,start:0}}}}return results}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(options){const key=`${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;return programCache[key]||(programCache[key]=new GpuProgram(options)),programCache[key]}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{m:()=>getAttributeInfoFromFormat});const attributeFormatData={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function getAttributeInfoFromFormat(format){return attributeFormatData[format]??attributeFormatData.float32}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{M:()=>Shader});var eventemitter3__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/node_modules/eventemitter3/index.mjs"),_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),_types_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");class Shader extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__.A{constructor(options){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram,glProgram,groups,resources,compatibleRenderers,groupMap}=options;this.gpuProgram=gpuProgram,this.glProgram=glProgram,void 0===compatibleRenderers&&(compatibleRenderers=0,gpuProgram&&(compatibleRenderers|=_types_mjs__WEBPACK_IMPORTED_MODULE_1__.W.WEBGPU),glProgram&&(compatibleRenderers|=_types_mjs__WEBPACK_IMPORTED_MODULE_1__.W.WEBGL)),this.compatibleRenderers=compatibleRenderers;const nameHash={};if(resources||groups||(resources={}),resources&&groups)throw new Error("[Shader] Cannot have both resources and groups");if(!gpuProgram&&groups&&!groupMap)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!gpuProgram&&groups&&groupMap)for(const i in groupMap)for(const j in groupMap[i]){const uniformName=groupMap[i][j];nameHash[uniformName]={group:i,binding:j,name:uniformName}}else if(gpuProgram&&groups&&!groupMap){const groupData=gpuProgram.structsAndGroups.groups;groupMap={},groupData.forEach((data=>{groupMap[data.group]=groupMap[data.group]||{},groupMap[data.group][data.binding]=data.name,nameHash[data.name]=data}))}else if(resources){if(gpuProgram){const groupData=gpuProgram.structsAndGroups.groups;groupMap={},groupData.forEach((data=>{groupMap[data.group]=groupMap[data.group]||{},groupMap[data.group][data.binding]=data.name,nameHash[data.name]=data}))}else{groupMap={},groups={99:new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.T},this._ownedBindGroups.push(groups[99]);let bindTick=0;for(const i in resources)nameHash[i]={group:99,binding:bindTick,name:i},groupMap[99]=groupMap[99]||{},groupMap[99][bindTick]=i,bindTick++}groups={};for(const i in resources){const name=i;let value=resources[i];value.source||value._resourceType||(value=new _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.k(value));const data=nameHash[name];data&&(groups[data.group]||(groups[data.group]=new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.T,this._ownedBindGroups.push(groups[data.group])),groups[data.group].setResource(value,data.binding))}}this.groups=groups,this._uniformBindMap=groupMap,this.resources=this._buildResourceAccessor(groups,nameHash)}addResource(name,groupIndex,bindIndex){var _a,_b;(_a=this._uniformBindMap)[groupIndex]||(_a[groupIndex]={}),(_b=this._uniformBindMap[groupIndex])[bindIndex]||(_b[bindIndex]=name),this.groups[groupIndex]||(this.groups[groupIndex]=new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.T,this._ownedBindGroups.push(this.groups[groupIndex]))}_buildResourceAccessor(groups,nameHash){const uniformsOut={};for(const i in nameHash){const data=nameHash[i];Object.defineProperty(uniformsOut,data.name,{get:()=>groups[data.group].getResource(data.binding),set(value){groups[data.group].setResource(value,data.binding)}})}return uniformsOut}destroy(destroyPrograms=!1){this.emit("destroy",this),destroyPrograms&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((bindGroup=>{bindGroup.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(options){const{gpu,gl,...rest}=options;let gpuProgram,glProgram;return gpu&&(gpuProgram=_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.B.from(gpu)),gl&&(glProgram=_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_5__.M.from(gl)),new Shader({gpuProgram,glProgram,...rest})}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{k:()=>UniformGroup});var uid=__webpack_require__("./node_modules/pixi.js/lib/utils/data/uid.mjs"),createIdFromString=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");function getDefaultUniformValue(type,size){switch(type){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*size);case"vec3<f32>":return new Float32Array(3*size);case"vec4<f32>":return new Float32Array(4*size);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const _UniformGroup=class _UniformGroup{constructor(uniformStructures,options){this._touched=0,this.uid=(0,uid.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,uid.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,options={..._UniformGroup.defaultOptions,...options},this.uniformStructures=uniformStructures;const uniforms={};for(const i in uniformStructures){const uniformData=uniformStructures[i];uniformData.name=i,uniformData.size=uniformData.size??1,uniformData.value??(uniformData.value=getDefaultUniformValue(uniformData.type,uniformData.size)),uniforms[i]=uniformData.value}this.uniforms=uniforms,this._dirtyId=1,this.ubo=options.ubo,this.isStatic=options.isStatic,this._signature=(0,createIdFromString.X)(Object.keys(uniforms).map((i=>`${i}-${uniformStructures[i].type}`)).join("-"),"uniform-group")}update(){this._dirtyId++}};_UniformGroup.defaultOptions={ubo:!1,isStatic:!1};let UniformGroup=_UniformGroup},"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>State});const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},_State=class _State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(value){!!(1&this.data)!==value&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(value){!!(2&this.data)!==value&&(this.data^=2)}set cullMode(value){"none"!==value?(this.culling=!0,this.clockwiseFrontFace="front"===value):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(value){!!(4&this.data)!==value&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(value){!!(8&this.data)!==value&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(value){!!(32&this.data)!==value&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(value){!!(16&this.data)!==value&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(value){this.blend="none"!==value,this._blendMode=value,this._blendModeId=blendModeIds[value]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(value){this.offsets=!!value,this._polygonOffset=value}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const state=new _State;return state.depthTest=!1,state.blend=!0,state}};_State.default2d=_State.for2d();let State=_State},"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{W:()=>TexturePool});var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/maths/misc/pow2.mjs"),_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"),_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");let count=0;const TexturePool=new class TexturePoolClass{constructor(textureOptions){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=textureOptions||{},this.enableFullScreen=!1}createTexture(pixelWidth,pixelHeight,antialias){const textureSource=new _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.v({...this.textureOptions,width:pixelWidth,height:pixelHeight,resolution:1,antialias,autoGarbageCollect:!0});return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.g({source:textureSource,label:"texturePool_"+count++})}getOptimalTexture(frameWidth,frameHeight,resolution=1,antialias){let po2Width=Math.ceil(frameWidth*resolution-1e-6),po2Height=Math.ceil(frameHeight*resolution-1e-6);po2Width=(0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__.U5)(po2Width),po2Height=(0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__.U5)(po2Height);const key=(po2Width<<17)+(po2Height<<1)+(antialias?1:0);this._texturePool[key]||(this._texturePool[key]=[]);let texture=this._texturePool[key].pop();return texture||(texture=this.createTexture(po2Width,po2Height,antialias)),texture.source._resolution=resolution,texture.source.width=po2Width/resolution,texture.source.height=po2Height/resolution,texture.source.pixelWidth=po2Width,texture.source.pixelHeight=po2Height,texture.frame.x=0,texture.frame.y=0,texture.frame.width=frameWidth,texture.frame.height=frameHeight,texture.updateUvs(),this._poolKeyHash[texture.uid]=key,texture}getSameSizeTexture(texture,antialias=!1){const source=texture.source;return this.getOptimalTexture(texture.width,texture.height,source._resolution,antialias)}returnTexture(renderTexture){const key=this._poolKeyHash[renderTexture.uid];this._texturePool[key].push(renderTexture)}clear(destroyTextures){if(destroyTextures=!1!==destroyTextures)for(const i in this._texturePool){const textures=this._texturePool[i];if(textures)for(let j=0;j<textures.length;j++)textures[j].destroy(!0)}this._texturePool={}}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{X:()=>createIdFromString});const idCounts=Object.create(null),idHash=Object.create(null);function createIdFromString(value,groupId){let id=idHash[value];return void 0===id&&(void 0===idCounts[groupId]&&(idCounts[groupId]=1),idHash[value]=id=idCounts[groupId]++),id}},"./node_modules/pixi.js/lib/rendering/renderers/types.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{W:()=>RendererType});var RendererType=(RendererType2=>(RendererType2[RendererType2.WEBGL=1]="WEBGL",RendererType2[RendererType2.WEBGPU=2]="WEBGPU",RendererType2[RendererType2.BOTH=3]="BOTH",RendererType2))(RendererType||{})},"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function color32BitToUniform(abgr,out,offset){const alpha=(abgr>>24&255)/255;out[offset++]=(255&abgr)/255*alpha,out[offset++]=(abgr>>8&255)/255*alpha,out[offset++]=(abgr>>16&255)/255*alpha,out[offset++]=alpha}__webpack_require__.d(__webpack_exports__,{V:()=>color32BitToUniform})},"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{K:()=>BatchableSprite});class BatchableSprite{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(float32View,uint32View,index,textureId){const sprite=this.renderable,texture=this.texture,wt=sprite.groupTransform,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty,bounds=this.bounds,w0=bounds.maxX,w1=bounds.minX,h0=bounds.maxY,h1=bounds.minY,uvs=texture.uvs,argb=sprite.groupColorAlpha,textureIdAndRound=textureId<<16|65535&this.roundPixels;float32View[index+0]=a*w1+c*h1+tx,float32View[index+1]=d*h1+b*w1+ty,float32View[index+2]=uvs.x0,float32View[index+3]=uvs.y0,uint32View[index+4]=argb,uint32View[index+5]=textureIdAndRound,float32View[index+6]=a*w0+c*h1+tx,float32View[index+7]=d*h1+b*w0+ty,float32View[index+8]=uvs.x1,float32View[index+9]=uvs.y1,uint32View[index+10]=argb,uint32View[index+11]=textureIdAndRound,float32View[index+12]=a*w0+c*h0+tx,float32View[index+13]=d*h0+b*w0+ty,float32View[index+14]=uvs.x2,float32View[index+15]=uvs.y2,uint32View[index+16]=argb,uint32View[index+17]=textureIdAndRound,float32View[index+18]=a*w1+c*h0+tx,float32View[index+19]=d*h0+b*w1+ty,float32View[index+20]=uvs.x3,float32View[index+21]=uvs.y3,uint32View[index+22]=argb,uint32View[index+23]=textureIdAndRound}packIndex(indexBuffer,index,indicesOffset){indexBuffer[index]=indicesOffset+0,indexBuffer[index+1]=indicesOffset+1,indexBuffer[index+2]=indicesOffset+2,indexBuffer[index+3]=indicesOffset+0,indexBuffer[index+4]=indicesOffset+2,indexBuffer[index+5]=indicesOffset+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);